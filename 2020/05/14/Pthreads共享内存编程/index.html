
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pthread共享内存编程 - Hodge</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Hodge,"> 
    <meta name="description" content="前言：本篇文章主要介绍下使用POSIX线程库，即Pthread在共享内存系统中进行多线程编程的基础范式，涉及的Pthread中的互斥量pthread_mutex_t、条件变量pthread_cond,"> 
    <meta name="author" content="Hodge-Zhang"> 
    <link rel="alternative" href="atom.xml" title="Hodge" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hodge</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://hodge-zhang.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Pthread共享内存编程</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Pthread共享内存编程</h1>
        <div class="stuff">
            <span>五月 14, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Pthread/" rel="tag">Pthread</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要介绍下使用POSIX线程库，即Pthread在<code>共享内存系统</code>中进行多线程编程的基础范式，涉及的Pthread中的互斥量<code>pthread_mutex_t</code>、条件变量<code>pthread_cond_t</code>以及<code>&lt;semaphore.h&gt;</code>中的信号量的基础使用。主要参考Peter S.Pacheco所著的《An Introduction to Parallel Programming》。在正文开始之前，有必要回顾以下概念：</p>
<ul>
<li><code>共享内存系统</code>：共享内存系统中的任意处理器核都能够访问所有的内存区域。因此，协调各个处理器核工作的一个方法，就是把某个内存区域设为“共享”，这是并行编程中常见的方法。</li>
</ul>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F.jpg" alt="图1：共享内存系统"></p>
<ul>
<li><p><code>临界区</code>：对共享内存区域进行更新的代码段称为临界区。</p>
</li>
<li><p><code>进程</code>：进程是正在运行（或挂起）的程序的一个实例，由操作系统管理。它包括：</p>
<ol>
<li><p>代码段</p>
</li>
<li><p>栈段</p>
</li>
<li><p>堆段。</p>
</li>
<li><p>系统为进程分配的资源描述符，如文件描述符等。</p>
</li>
<li><p>安全信息，如进程允许访问的硬件和软件资源。</p>
</li>
<li><p>描述进程状态的信息，如进程是否准备运行或者正在等待某个资源，寄存器中的内容（包括程序计数器数值）等。</p>
</li>
</ol>
</li>
<li><p><code>线程</code>：它来自于“控制线程”的概念，控制线程是程序中的一个语句序列，也可以说是进程中的一个单一顺序的控制流，是cpu调度的基本单位。</p>
</li>
<li><p><code>缓存一致性</code>：指在采用层次结构存储系统的计算机系统中，cpu不同核的 catch中的数据与主存中的数据保持相同。为了达到缓存一致性的目的，出现了多种缓存一致性协议，常用的是<code>窥探（snooping）协议</code>。</p>
</li>
<li><p><code>伪共享</code>：线程并不共享任何东西（除了一个缓存行），但线程对内存访问的行为好像它们正在共享一个变量，因此把这种现象命名为伪共享。</p>
</li>
<li><p><code>线程安全</code>：如果一个代码块能够被多个线程同时执行而不引起问题，那么它是线程安全的。</p>
</li>
<li><p><code>互斥量(mutex)</code>：可以被看做是临界区的一把锁，它是一个特殊类型的变量，通过某些特殊类型的函数，互斥量可以用来限制每次只有一个线程能进入临界区，以保证对临界区的互斥 访问。</p>
</li>
<li><p><code>信号量(semaphore)</code>：是一个有两个操作（<code>sem_wait</code>和<code>sem_post</code>）的无符号型整数。如果信号量是正的，对<code>sem_wait</code>的调用就简单地将信号量减1；如果信号量是零，调用<code>sem_wait</code>的线程就会阻塞直到信号量为正数，此时信号量会减1，然后线程从调用中返回。<code>sem_post</code>操作使信号量加1。信号量比互斥量功能更强，因为它们能够初始化为任何非负值。而且，因为信号量没有“归属权”，任何线程都能够对锁上的信号量进行解锁。</p>
</li>
<li><p><code>条件变量(conditional variable)</code>：是一个特殊的线程对象，它用来挂起一个线程的执行直到某个条件发生。一旦条件发生，另一个线程能够用一个条件信号或一个条件广播唤醒挂起的线程。</p>
</li>
<li><p><code>路障(barrier)</code>是程序中的一个结点，线程必须阻塞直到所有的线程都到达了这个结点。路障另一个非常重要的应用是调试程序。</p>
</li>
</ul>
<h2 id="1-多线程的Hello-World"><a href="#1-多线程的Hello-World" class="headerlink" title="1. 多线程的Hello World"></a>1. 多线程的Hello World</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File:  </span></span><br><span class="line"><span class="comment"> *    pth_hello.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> *    Illustrate basic use of pthreads:  create some threads,</span></span><br><span class="line"><span class="comment"> *    each of which prints a message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *    none</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *    message from each thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Compile:  gcc -g -Wall -o pth_hello pth_hello.c -lpthread</span></span><br><span class="line"><span class="comment"> * Usage:    ./pth_hello &lt;thread_count&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IPP:   Section 4.2 (p. 153 and ff.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variable:  accessible to all threads */</span></span><br><span class="line"><span class="keyword">int</span> thread_count;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>;  <span class="comment">/* Thread function */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span>       thread;  <span class="comment">/* Use long in case of a 64-bit system */</span></span><br><span class="line">   <span class="keyword">pthread_t</span>* thread_handles; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Get number of threads from command line */</span></span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) Usage(argv[<span class="number">0</span>]);</span><br><span class="line">   thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);  </span><br><span class="line">   <span class="keyword">if</span> (thread_count &lt;= <span class="number">0</span> || thread_count &gt; MAX_THREADS) Usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   thread_handles = <span class="built_in">malloc</span> (thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)  </span><br><span class="line">      pthread_create(&amp;thread_handles[thread], <span class="literal">NULL</span>,</span><br><span class="line">          Hello, (<span class="keyword">void</span>*) thread);  </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from the main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++) </span><br><span class="line">      pthread_join(thread_handles[thread], <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(thread_handles);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> my_rank = (<span class="keyword">long</span>) rank;  <span class="comment">/* Use long in case of 64-bit system */</span> </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld of %d\n"</span>, my_rank, thread_count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  <span class="comment">/* Hello */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;number of threads&gt;\n"</span>, prog_name);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"0 &lt; number of threads &lt;= %d\n"</span>, MAX_THREADS);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  <span class="comment">/* Usage */</span></span><br></pre></td></tr></table></figure>

<p>对以上程序的解读：</p>
<ol>
<li><p><code>pthread_t</code>数据结构用来存储线程的专有信息，它由<code>pthread.h</code>声明。要注意的是，<code>pthread_t</code>对象是一个不透明对象。对象中存储的数据都是系统绑定的，用户级代码无法直接访问到里面的数据。</p>
</li>
<li><p>下面是<code>pthread_create</code>函数的参数信息。<br>第一个参数是一个指针，指向对应的<code>pthread_t</code>对象。注意，<code>pthread_t</code>对象不是由<code>pthread_create</code>函数分配的，必须在调用<code>pthread_create</code>函数前就为<code>pthread_t</code>对象分配内存空间。<br>第二个参数一般不用，所以只是在函数调用时把NULL传递给参数。<br>第三个参数表示该线程将要运行的函数，下面会具体讲；<br>最后一个参数也是一个指针，指向传给函数start_routine的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	pthread.t* thread-p,			</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr_p,				</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* arg_p					</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由<code>pthread_create</code>生成并运行的函数应该有一个类似于下面函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span>* args_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为类型<code>void*</code>可以转换为C语言中任意指针类型，所以args_p可以指向一个列表，该列表包含一个或多个thread_function函数需要的数值。其返回值亦是如此。通常，参数列表里会传入一个int型<code>rank</code>参数，用于给线程显式的编号，以便于多线程代码的调试。注意，当线程结束时，由于它的函数的类型有一个返回值，那么线程就应该返回一个值。在本例中，线程没有需要特别返回的值，所以只返回NULL。</p>
</li>
<li><p><code>pthread_join</code>函数用于合并<code>pthread_create</code>创建的线程到主线程。第二个参数可以接收任意由<code>pthread_t</code>对象所关联的那个线程产生的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_t</span> thread,		</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ret_val_p			</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-临界区问题"><a href="#2-临界区问题" class="headerlink" title="2. 临界区问题"></a>2. 临界区问题</h2><p>共享内存的确使得多线程之间变量的共享变得方便了许多，但同时也带来了一个很大的问题：当多个线程尝试更新同一个共享变量时，会出问题。因此，多线程的程序应该保证一次只允许一个线程执行同一临界区的代码段。解决这个问题的方法主要有：</p>
<ul>
<li><p>忙等待：设置一个共享的int型变量flag，只有flag等于当前线程的rank时，当前线程才能访问临界区，否则忙等待，处于忙等待的线程仍然在持续使用CPU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">临界区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">flag++;</span><br></pre></td></tr></table></figure>

<p>有时候编译器进行编译优化时为了充分利用寄存器，可能会将临界区代码提到while之前，这将导致忙等待失效，因此进行相关实验时关闭编译优化的选项是个好办法。</p>
</li>
<li><p>互斥量：Pthreads标准为互斥量提供了一个特殊类型：<code>pthread_mutex_t</code>。在使用<code>pthread_mutex_t</code>类型的变量前，必须由系统对其进行初始化，初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pthread_mutext* mutex-p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span>* attr-p 	</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用第二个参数，给这个参数赋值NULL即可。当一个Pthreads程序使用完互斥量后，它应该调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要获得临界区的访问权，线程需调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程退出临界区后，它应该调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t* mutex_p)；</span><br></pre></td></tr></table></figure>

<p>调用<code>pthread_mutex_lock</code>会使线程等待，直到没有其他线程进入临界区；调用<code>pthread_mutex_unlock</code> 则通知系统该线程已经完成了临界区中代码的执行。</p>
<p>如果把线程数增加到超过核的个数，那么采用互斥量程序的性能仍然维持不变，但忙等待程序的性能就会下降。尽管忙等待总是浪费CPU的资源，但它是我们至今所知的，能事先确定线程执行临界区代码顺序的最适合方法：线程0最先执行，然后线程1，接下来线程2等。如果采用互斥量，那么哪个线程先进人临界区以及此后的顺序由系统随机选取。</p>
</li>
<li><p>信号量：信号量可以认为是一种特殊类型的unsigned int无符号整型变量，可以赋值为0、1、2、…。大多数情况下，只给它们赋值0和1，这种只有0和1值的信号量称为二元信号量。<br>信号量与互斥量最大的区别在于信号量是没有个体拥有权的，主线程将所有的信号量初始化为0，即“加锁”，其他线程都能对任何信号量调用<code>sem_post</code>和<code>sem_wait</code>函数。<br>不同信号量函数的语法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">sem_t</span>* semaphore_p, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> shared, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> initial_val</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用<code>sem_init</code>函数的第二个参数，对这个参数只需传人常数0即可。注意，信号量不是Pthreads线程库的一部分，所以需要在使用信号量的程序开头加头文件。</p>
</li>
<li><p>条件变量：它是一个数据对象，允许线程在某个特定条件或事件发生前都处于挂起状态。当事件或条件发生时，另一个线程可以通过信号来唤醒挂起的线程。一个条件变量总是与一个互斥量相关联。<br>Pthreads线程库中的条件变量类型为<code>pthread_cond_t</code>。函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_signal(pthread_cond_t* cond_var_p)；</span><br></pre></td></tr></table></figure>

<p>的作用是解锁一个阻塞的线程，而函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond_var_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>的作用是解锁所有被阻塞的线程。函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_cond_t</span>* cond_var_p,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_mutex_t</span>* mutex_p</span></span></span><br><span class="line"><span class="function"><span class="params">）；</span></span></span><br></pre></td></tr></table></figure>

<p>的作用是通过互斥量<code>mutex_p</code>来阻塞线程，直到其他线程调用<code>pthread_cond_signal</code>或者<code>pthread_cond_broadcast</code>来解锁它。当线程解锁后，它重新获得互斥量。所以实际上，<code>pthread_cond_wait</code>相当于按顺序执行了以下的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp; mutex_p); </span><br><span class="line">wait_on_signal(&amp; cond_var_p); </span><br><span class="line">pthread_mutex_lock(&amp; mutex_p):</span><br></pre></td></tr></table></figure>

<p>与互斥量和信号量一样，条件变量也应该初始化和销毁。对应的函数是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_cond_t</span>* cond_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_cond_attr_t</span>* cond_attr_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">int pthread_cond_destroy(pthread_cond_t* cond_p)：</span><br></pre></td></tr></table></figure>

<p>我们一般不使用<code>pthread_cond_init</code>的第二个参数（调用函数时传递NULL作为参数值）。</p>
</li>
</ul>
<h2 id="3-实现读写锁"><a href="#3-实现读写锁" class="headerlink" title="3. 实现读写锁"></a>3. 实现读写锁</h2><p>读写锁实现方式有很多种，这里的是使用互斥量核条件变量来实现。</p>
<p>互斥量用于保护读写锁的数据：无论何时一个线程调用其中的任意一个函数（读锁、写锁、解锁），它必须首先锁互斥量，并且无论何时一个线程完成了这些函数调用中的一个，它必须解锁互斥量。在获取互斥量后，线程检查合适的数据成员来决定接下来干什么。例如，如果它想要进行读访问，就检查是否有一个写者当前拥有锁。如果没有，它对活动读者（即同时读的线程）的数量加1，然后继续执行随后的操作。如果有一个活动写者（有一个写者拥有锁，正在写），就为等待获取锁的读者的数量加1，并且在读者条件变量上启动一个条件等待。当它被条件唤醒后，它将正在等待的读者的数量减1，对活动读者的数量加1，并继续执行随后的操作。写锁函数的实现与读锁函数相类似。</p>
<p>解锁函数的操作取决于线程是一个读者还是一个写者。如果线程是一个读者，且没有其他的活动读者，并且一个写者正在等待，那么它就在返回前发送信号通知写者，使写者继续后继的操作。另一方面，如果线程是写者，则可能同时有读者和写者正在等待，因此线程需要决定它倾向于读者还是写者。因为写者必须互斥访问，很可能写者更难获得锁。因此，给予写者优先权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rw_lock_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> NoOfReaders;	<span class="comment">// 读者数量</span></span><br><span class="line">    <span class="keyword">int</span> NoOfWriters, NoOfWritersWaiting;	<span class="comment">// 写者-等待数量</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> class_mutex;	<span class="comment">// 互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  reader_con;	<span class="comment">// 读者条件变量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  writer_con;	<span class="comment">// 写者条件变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 写-写 互斥</span></span><br><span class="line"><span class="comment">	* 写-读 互斥</span></span><br><span class="line"><span class="comment">	* 读-读 共享</span></span><br><span class="line"><span class="comment">	* 读-写 互斥</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">rw_lock_t</span>()</span><br><span class="line">    : NoOfReaders(<span class="number">0</span>), NoOfWriters(<span class="number">0</span>), NoOfWritersWating(<span class="number">0</span>),</span><br><span class="line">      class_mutex(PTHREAD_MUTEX_INITIALIZER),</span><br><span class="line">      reader_con(PTHREAD_COND_INITIALIZER),</span><br><span class="line">      writer_con(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">	<span class="comment">// 析构</span></span><br><span class="line">    ~<span class="keyword">rw_lock_t</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;class_mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;reader_con);</span><br><span class="line">        pthread_cond_destroy(&amp;writer_con);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        <span class="comment">//while(NoOfWriters&gt;0 || NoOfWritersWaiting&gt;0)	// 写者优先</span></span><br><span class="line">        <span class="keyword">while</span>(NoOfWriters&gt;<span class="number">0</span>)	</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;reader_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfReaders++;        </span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWritersWaiting++;</span><br><span class="line">        <span class="keyword">while</span>(NoOfReaders&gt;<span class="number">0</span> || NoOfWriters&gt;<span class="number">0</span>)	<span class="comment">// 锁被占用则等待</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;writer_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfWritersWaiting--; NoOfWriters++;</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfReaders--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfReaders==<span class="number">0</span> &amp;&amp; NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWriters--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        <span class="comment">//else	// 写者优先——直到没有写者才解锁读者</span></span><br><span class="line">        pthread_cond_broadcast(&amp;reader_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Era-The%20Mass.flac'></li>
                        
                    
                        
                            <li title='1' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Klaus%20Badelt-He%27s%20a%20Pirate.flac'></li>
                        
                    
                        
                            <li title='2' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Ramin%20Djawadi-Game%20Of%20Thrones.flac'></li>
                        
                    
                        
                            <li title='3' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Thomas%20Bergersen%26Two%20Steps%20From%20Hell-Black%20Blade.flac'></li>
                        
                    
                        
                            <li title='4' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Two%20Steps%20From%20Hell-Empire%20Of%20Angels.flac'></li>
                        
                    
                        
                            <li title='5' data-url='https://2020-05-13-my-online-music.oss-cn-beijing.aliyuncs.com/2020-05-blob-music/Two%20Steps%20From%20Hell-Star%20Sky%20%28Orchestral%29.flac'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='5b7bd8b8038fc288e143'
        data-cs='0cba3b34c218c7cd5992e059041025cd976536be'
        data-r='Hodge-Zhang.github.io'
        data-o='Hodge-Zhang'
        data-a='Hodge-Zhang'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
