<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo问题记录</title>
    <url>/2020/05/13/hexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>执行<code>hexo g</code>生成静态网页时出错：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">YAMLException: end of the stream or a document separator is expected at line x, column y: ...</span></span><br></pre></td></tr></table></figure>

<p>原因：hexo <code>_posts</code>文件夹内的<code>.md</code>文件头部应该有一些头部<code>meta</code>信息来初始化一些配置的变量，这些信息在执行命令<code>hexo n filename</code>创建新的文章时会自动加上，但若直接从外部创建一个Markdown文件到<code>_posts</code>文件夹内，然后执行命令创建静态网页时就会因为得不到相关信息报以上的错误。</p>
<p>比如<code>diaspora</code>主题的头部信息为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: My awesome title</span><br><span class="line">date: 2020-1-12 18:38:45</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>分类1</span><br><span class="line"><span class="bullet">    - </span>分类2</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>标签1</span><br><span class="line"><span class="bullet">    - </span>标签2</span><br><span class="line">mp3: http://domain.com/awesome.mp3</span><br><span class="line">cover: http://domain.com/awesome-cover.png</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">更多关于hexo头部信息的内容</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>diaspora</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题diaspora</title>
    <url>/2020/05/13/hexo%E4%B8%BB%E9%A2%98diaspora/</url>
    <content><![CDATA[<p><strong><a href="http://fech.in" target="_blank" rel="noopener">在线预览 | PREVIEW </a></strong></p>
<p>一款基于WP移植的Hexo主题，适合喜欢摄影，影评，乐评和玩弄文字的你，干净，清新； 响应式，Ajax，更多好玩的等你来发现。 </p>
<blockquote>
<p>再次感谢原作者创作出这么精美的主题 <a href="https://github.com/LoeiFy/Diaspora" target="_blank" rel="noopener">@Loeify</a> 。如果你喜欢，请捐助原作者。</p>
</blockquote>
<p><img src="https://fech.in/static/images/Diaspora.jpg" alt="cover"></p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Fechin/hexo-theme-diaspora.git themes/diaspora</span><br></pre></td></tr></table></figure>


<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改Hexo配置文件 <code>_config.yml</code> 主题项设置为diaspora</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">diaspora</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><p>注意：请在更时主题时备份<code>_config.yml</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/diaspora</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<h3 id="新建文章模板"><a href="#新建文章模板" class="headerlink" title="新建文章模板"></a>新建文章模板</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: My awesome title</span><br><span class="line">date: 2016-10-12 18:38:45</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>分类1</span><br><span class="line"><span class="bullet">    - </span>分类2</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>标签1</span><br><span class="line"><span class="bullet">    - </span>标签2</span><br><span class="line">mp3: http://domain.com/awesome.mp3</span><br><span class="line">cover: http://domain.com/awesome.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="创建分类页"><a href="#创建分类页" class="headerlink" title="创建分类页"></a>创建分类页</h3><p>1 新建一个页面，命名为 categories 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>2 编辑刚新建的页面，将页面的类型设置为 categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>主题将自动为这个页面显示所有分类。</p>
<h3 id="创建标签页"><a href="#创建标签页" class="headerlink" title="创建标签页"></a>创建标签页</h3><p>1 新建一个页面，命名为 tags 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>2 编辑刚新建的页面，将页面的类型设置为 tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>主题将自动为这个页面显示所有标签。</p>
<h3 id="创建搜索页"><a href="#创建搜索页" class="headerlink" title="创建搜索页"></a>创建搜索页</h3><p>1 需要安装hexo的搜索插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2 配置hexo全局配置文件（请将生成的索引文件放在网站根目录或修改主题js文件的path值）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>3 新建一个页面，命名为 search 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page search</span><br></pre></td></tr></table></figure>
<p>4 编辑刚新建的页面，将页面的类型设置为 search</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: search</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;search&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>5 在主题配置文件启用本地搜索</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地搜索,请将索引文件放在网站根目录</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="comment">#是否启用</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>主题将自动为这个页面显示搜索功能。</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头部菜单，title: link</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span>  </span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示目录</span></span><br><span class="line"><span class="attr">TOC:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否自动播放音乐</span></span><br><span class="line"><span class="attr">autoplay:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认音乐（随机播放）</span></span><br><span class="line"><span class="attr">mp3:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">http://link.hhtjim.com/163/425570952.mp3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">http://link.hhtjim.com/163/425570952.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首页封面图, 为空时取文章的cover作为封面(注意跨域问题,建议使用同源图片)</span></span><br><span class="line"><span class="attr">welcome_cover:</span> <span class="string">/img/welcome-cover.jpg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认文章封面图（随机调用,支持外链）</span></span><br><span class="line"><span class="attr">cover:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/img/cover.jpg</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/img/welcome-cover.jpg</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 是否关闭默认滚动条</span></span><br><span class="line"><span class="attr">scrollbar:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地搜索,请将索引文件放在网站根目录,或修改主题js文件的path值</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># 是否启用</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示 一言(hitokoto)</span></span><br><span class="line"><span class="attr">hitokoto:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接(可选:facebook,twitter,github,wechat,email)</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">    <span class="attr">facebook:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">twitter:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">wechat:</span> <span class="string">/img/logo.png</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">mailto:xxxx@gmail.com</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 备案</span></span><br><span class="line"><span class="attr">beian:</span> </span><br><span class="line">    <span class="comment"># 是否显示备案信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否在主页面最底下显示备案信息(虽然丑，但是完全满足规定要求)</span></span><br><span class="line">    <span class="attr">enableFooter:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 备案号</span></span><br><span class="line">    <span class="attr">beianInfo:</span> <span class="string">冀ICP备xxxxxxx号</span></span><br><span class="line">    <span class="comment"># 链接地址</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">http://www.beian.miit.gov.cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否使用mathjax</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitalk 评论插件（https://github.com/gitalk/gitalk）</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="comment"># 是否启用评论功能</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否自动展开评论框</span></span><br><span class="line">    <span class="attr">autoExpand:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 应用编号</span></span><br><span class="line">    <span class="attr">clientID:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># 应用秘钥</span></span><br><span class="line">    <span class="attr">clientSecret:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># issue仓库名</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Github名</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Github名</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">['']</span></span><br><span class="line">    <span class="comment"># Ensure uniqueness and length less than 50</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">location.pathname</span></span><br><span class="line">    <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">    <span class="attr">distractionFreeMode:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站关键字</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Fechin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用google_analytics进行统计的话，这里需要配置ID</span></span><br><span class="line"><span class="attr">google_analytics:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站ico</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rss文件</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">atom.xml</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 基础使用</title>
    <url>/2020/05/13/Markdown%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如今，不少内容发布者都使用Markdown 发布内容，而我昨天刚建的基于<code>hexo</code>的博客，也需要使用Markdown，鉴于最近才真正接触Markdown，所以在建站完成伊始先写篇博客总结下Markdown 的使用规则及技巧。</p>
<h2 id="1-Markdown简介"><a href="#1-Markdown简介" class="headerlink" title="1. Markdown简介"></a>1. Markdown简介</h2><p>Markdown是一种轻量级的<code>标记语言</code>，由John Gruber在2004年创建，其核心思想是格式与内容分离，这也符合今天网页的思想。它允许人们使用纯文本格式编写文档，使用Markdown编写的文档可以导出html、word、图像、pdf、epub 等多种格式的文档，常用来发布博客内容。Markdown 文档的后缀为<code>.md</code>或者<code>.markdown</code>。</p>
<h2 id="2-Markdown基础语法"><a href="#2-Markdown基础语法" class="headerlink" title="2. Markdown基础语法"></a>2. Markdown基础语法</h2><p>基础语法包括“标题”、“字体”、“列表”、“区块”，“代码”，“链接”，“图片”，“表格”这8大部分，能满足绝大多数文章的写作需求。</p>
<h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>共有6种级别的标题，用<code>#</code>标识，注意<code>#</code>与标题之间应有一个空格,接下来的内容也有注意区分语法中有无空格。一级标题后面会有一条分隔线。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>Markdown段落没有特殊的格式，直接编写文字即可。段落的换行是两个以上的空格+回车，当然也可以在段落后面直接使用一个空行表示重新开始一个段落。事实上，很多版本直接回车也是可以的。</p>
<p>Markdown的字体格式主要是“斜体”，“加粗”，此外还有一些格式如“下划线”，“删除线”，“分隔线”等。</p>
<p>下划线：实际上使用的是HTML里的<code>&lt;u&gt;</code>标签实现的。</p>
<p>删除线：文字两端分别加上两个波浪线<code>~</code>。</p>
<p>分隔线：在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西，也可以在星号或是减号中间插入空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本一*</span></span><br><span class="line"><span class="emphasis">_斜体文本二_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本一**</span></span><br><span class="line"><span class="strong">__粗体文本二__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">***粗斜体文本一**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本二__</span>_</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="bullet">- </span>- - - - -</span><br><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span> <span class="emphasis">* *</span> *</span><br><span class="line"></span><br><span class="line">~~删除线~~ </span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>斜体文本一</em><br><em>斜体文本二</em></p>
<p><strong>粗体文本一</strong><br><strong>粗体文本二</strong></p>
<p><strong><em>粗斜体文本一</em></strong><br><strong><em>粗斜体文本二</em></strong></p>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<hr>
<h3 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3 列表"></a>2.3 列表</h3><p>列表分有序列表和无须列表，前者使用形如<code>1.</code>直接标识，后者使用<code>*</code>、<code>+</code>或者<code>-</code>来标识。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-区块"><a href="#2-4-区块" class="headerlink" title="2.4 区块"></a>2.4 区块</h3><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code>符号 ，然后后面紧跟一个空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用1</span></span><br><span class="line"><span class="quote">&gt; 引用2</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line">&gt;&gt; 嵌套1</span><br><span class="line">&gt;&gt;&gt; 嵌套2</span><br><span class="line">&gt;&gt;&gt; - 第一项</span><br><span class="line">&gt;&gt;&gt; - 第二项</span><br><span class="line">&gt;&gt;&gt; - 第三项</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>最外层</p>
<blockquote>
<p>嵌套1</p>
<blockquote>
<p>嵌套2</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号`把它包起来，如果是代码块可以在其前后两行分别使用```来包裹，也可选择在前面指定编程语言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// your code is here</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-链接"><a href="#2-6-链接" class="headerlink" title="2.6 链接"></a>2.6 链接</h3><p>链接使用方法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">直接使用链接地址</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">[<span class="string">My Blob</span>](<span class="link">https://hodge-zhang.gitee.io/</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">hodge-zhang.github.io</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://hodge-zhang.gitee.io/" target="_blank" rel="noopener">My Blob</a></p>
<p><a href="https://hodge-zhang.github.io/" target="_blank" rel="noopener">https://hodge-zhang.github.io/</a></p>
<hr>
<h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><p>Markdown 图片语法格式如下：</p>
<ul>
<li>开头一个感叹号<code>！</code></li>
<li>接着一个方括号，里面放上图片无法加载时的替代文字，<code>[alt 属性文本]</code></li>
<li>最后是一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的<code>title</code> 属性的文字，(图片地址 “可选title”)</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">生命不息</span>](<span class="link">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/bycle.jpg "生命"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/bycle.jpg" alt="生命不息" title="生命"></p>
<p>值得注意的是，Markdown写作的一个痛点就是图片的嵌入，它不像<code>.docx</code>那样文字与图片一起编码成一个独立的文件，Markdown是从外部通过统一资源定位符<code>URL</code>引入，这意味着带图片的Markdown文章要想在互联网上发布并被不同的人完整的看到，其图片必须在某个服务器上，由服务器来管理图片资源，管理图片的服务器就是图床了，目前我所使用的是阿里云的OSS自建的图床，从上面图片的链接中也可以看出来。关于图床的使用可以单独发出一篇文章来讲，这里就不多说了。</p>
<h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。同时我们也可以设置表格的对齐对齐方式：</p>
<ul>
<li><code>-:</code>设置内容和标题栏居右对齐。</li>
<li><code>:-</code> 设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">| :-----| :---: | ----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

<hr>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
</tbody></table>
<hr>
<p>从Markdown表格源码中可以看到使用Markdown制作表格比较麻烦的，实际写作过程中，像制作表格、绘制流程图、绘制时序图等一般借助第三方工具完成。</p>
<h2 id="3-Markdown-相关工具"><a href="#3-Markdown-相关工具" class="headerlink" title="3. Markdown 相关工具"></a>3. Markdown 相关工具</h2><p>作为一种使用了十几年的工具，基于Markdown也衍生出了很多的工具，这里只推荐我所使用的。</p>
<ul>
<li>编辑工具：<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，这篇文章即是使用这个工具写的，软件做的很棒，堪称优雅。</li>
<li>图片管理：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，功能齐全的图片管理工具，支持大多数图床，和Typora完美适配。</li>
<li>自建图床：<a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a>，作为国内商业化最好的云产品，40G OSS对象存储空间一年只需9RMB，是建立自己的云的不二之选了。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Pthread共享内存编程</title>
    <url>/2020/05/14/Pthreads%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要介绍下使用POSIX线程库，即Pthread在<code>共享内存系统</code>中进行多线程编程的基础范式，涉及的Pthread中的互斥量<code>pthread_mutex_t</code>、条件变量<code>pthread_cond_t</code>以及<code>&lt;semaphore.h&gt;</code>中的信号量的基础使用。主要参考Peter S.Pacheco所著的《An Introduction to Parallel Programming》。在正文开始之前，有必要回顾以下概念：</p>
<ul>
<li><code>共享内存系统</code>：共享内存系统中的任意处理器核都能够访问所有的内存区域。因此，协调各个处理器核工作的一个方法，就是把某个内存区域设为“共享”，这是并行编程中常见的方法。</li>
</ul>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F.jpg" alt="图1：共享内存系统"></p>
<ul>
<li><p><code>临界区</code>：对共享内存区域进行更新的代码段称为临界区。</p>
</li>
<li><p><code>进程</code>：进程是正在运行（或挂起）的程序的一个实例，由操作系统管理。它包括：</p>
<ol>
<li><p>代码段</p>
</li>
<li><p>栈段</p>
</li>
<li><p>堆段。</p>
</li>
<li><p>系统为进程分配的资源描述符，如文件描述符等。</p>
</li>
<li><p>安全信息，如进程允许访问的硬件和软件资源。</p>
</li>
<li><p>描述进程状态的信息，如进程是否准备运行或者正在等待某个资源，寄存器中的内容（包括程序计数器数值）等。</p>
</li>
</ol>
</li>
<li><p><code>进程</code>：它来自于“控制线程”的概念，控制线程是程序中的一个语句序列，也可以说是进程中的一个单一顺序的控制流，是cpu调度的基本单位。</p>
</li>
<li><p><code>缓存一致性</code>：指在采用层次结构存储系统的计算机系统中，cpu不同核的 catch中的数据与主存中的数据保持相同。为了达到缓存一致性的目的，出现了多种缓存一致性协议，常用的是<code>窥探（snooping）协议</code>。</p>
</li>
<li><p><code>伪共享</code>：线程并不共享任何东西（除了一个缓存行），但线程对内存访问的行为好像它们正在共享一个变量，因此把这种现象命名为伪共享。</p>
</li>
<li><p><code>线程安全</code>：如果一个代码块能够被多个线程同时执行而不引起问题，那么它是线程安全的。</p>
</li>
<li><p><code>互斥量(mutex)</code>：可以被看做是临界区的一把锁，它是一个特殊类型的变量，通过某些特殊类型的函数，互斥量可以用来限制每次只有一个线程能进入临界区，以保证对临界区的互斥 访问。</p>
</li>
<li><p><code>信号量(semaphore)</code>：是一个有两个操作（<code>sem_wait</code>和<code>sem_post</code>）的无符号型整数。如果信号量是正的，对<code>sem_wait</code>的调用就简单地将信号量减1；如果信号量是零，调用<code>sem_wait</code>的线程就会阻塞直到信号量为正数，此时信号量会减1，然后线程从调用中返回。<code>sem_post</code>操作使信号量加1。信号量比互斥量功能更强，因为它们能够初始化为任何非负值。而且，因为信号量没有“归属权”，任何线程都能够对锁上的信号量进行解锁。</p>
</li>
<li><p><code>条件变量(conditional variable)</code>：是一个特殊的线程对象，它用来挂起一个线程的执行直到某个条件发生。一旦条件发生，另一个线程能够用一个条件信号或一个条件广播唤醒挂起的线程。</p>
</li>
<li><p><code>路障(barrier)</code>是程序中的一个结点，线程必须阻塞直到所有的线程都到达了这个结点。路障另一个非常重要的应用是调试程序。</p>
</li>
</ul>
<h2 id="1-多线程的Hello-World"><a href="#1-多线程的Hello-World" class="headerlink" title="1. 多线程的Hello World"></a>1. 多线程的Hello World</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* File:  </span></span><br><span class="line"><span class="comment"> *    pth_hello.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> *    Illustrate basic use of pthreads:  create some threads,</span></span><br><span class="line"><span class="comment"> *    each of which prints a message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *    none</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *    message from each thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Compile:  gcc -g -Wall -o pth_hello pth_hello.c -lpthread</span></span><br><span class="line"><span class="comment"> * Usage:    ./pth_hello &lt;thread_count&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IPP:   Section 4.2 (p. 153 and ff.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variable:  accessible to all threads */</span></span><br><span class="line"><span class="keyword">int</span> thread_count;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>;  <span class="comment">/* Thread function */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span>       thread;  <span class="comment">/* Use long in case of a 64-bit system */</span></span><br><span class="line">   <span class="keyword">pthread_t</span>* thread_handles; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Get number of threads from command line */</span></span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) Usage(argv[<span class="number">0</span>]);</span><br><span class="line">   thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);  </span><br><span class="line">   <span class="keyword">if</span> (thread_count &lt;= <span class="number">0</span> || thread_count &gt; MAX_THREADS) Usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   thread_handles = <span class="built_in">malloc</span> (thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)  </span><br><span class="line">      pthread_create(&amp;thread_handles[thread], <span class="literal">NULL</span>,</span><br><span class="line">          Hello, (<span class="keyword">void</span>*) thread);  </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from the main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++) </span><br><span class="line">      pthread_join(thread_handles[thread], <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(thread_handles);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> my_rank = (<span class="keyword">long</span>) rank;  <span class="comment">/* Use long in case of 64-bit system */</span> </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld of %d\n"</span>, my_rank, thread_count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  <span class="comment">/* Hello */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;number of threads&gt;\n"</span>, prog_name);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"0 &lt; number of threads &lt;= %d\n"</span>, MAX_THREADS);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  <span class="comment">/* Usage */</span></span><br></pre></td></tr></table></figure>

<p>对以上程序的解读：</p>
<ol>
<li><p><code>pthread_t</code>数据结构用来存储线程的专有信息，它由<code>pthread.h</code>声明。要注意的是，<code>pthread_t</code>对象是一个不透明对象。对象中存储的数据都是系统绑定的，用户级代码无法直接访问到里面的数据。</p>
</li>
<li><p>下面是<code>pthread_create</code>函数的参数信息。<br>第一个参数是一个指针，指向对应的<code>pthread_t</code>对象。注意，<code>pthread_t</code>对象不是由<code>pthread_create</code>函数分配的，必须在调用<code>pthread_create</code>函数前就为<code>pthread_t</code>对象分配内存空间。<br>第二个参数一般不用，所以只是在函数调用时把NULL传递给参数。<br>第三个参数表示该线程将要运行的函数，下面会具体讲；<br>最后一个参数也是一个指针，指向传给函数start_routine的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	pthread.t* thread-p,			</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr_p,				</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* arg_p					</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由<code>pthread_create</code>生成并运行的函数应该有一个类似于下面函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span>* args_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为类型<code>void*</code>可以转换为C语言中任意指针类型，所以args_p可以指向一个列表，该列表包含一个或多个thread_function函数需要的数值。其返回值亦是如此。通常，参数列表里会传入一个int型<code>rank</code>参数，用于给线程显式的编号，以便于多线程代码的调试。注意，当线程结束时，由于它的函数的类型有一个返回值，那么线程就应该返回一个值。在本例中，线程没有需要特别返回的值，所以只返回NULL。</p>
</li>
<li><p><code>pthread_join</code>函数用于合并<code>pthread_create</code>创建的线程到主线程。第二个参数可以接收任意由<code>pthread_t</code>对象所关联的那个线程产生的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_t</span> thread,		</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ret_val_p			</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-临界区问题"><a href="#2-临界区问题" class="headerlink" title="2. 临界区问题"></a>2. 临界区问题</h2><p>共享内存的确使得多线程之间变量的共享变得方便了许多，但同时也带来了一个很大的问题：当多个线程尝试更新同一个共享变量时，会出问题。因此，多线程的程序应该保证一次只允许一个线程执行同一临界区的代码段。解决这个问题的方法主要有：</p>
<ul>
<li><p>忙等待：设置一个共享的int型变量flag，只有flag等于当前线程的rank时，当前线程才能访问临界区，否则忙等待，处于忙等待的线程仍然在持续使用CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">临界区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">flag++;</span><br></pre></td></tr></table></figure>

<p>有时候编译器进行编译优化时为了充分利用寄存器，可能会将临界区代码提到while之前，这将导致忙等待失效，因此进行相关实验时关闭编译优化的选项是个好办法。</p>
</li>
<li><p>互斥量：Pthreads标准为互斥量提供了一个特殊类型：<code>pthread_mutex_t</code>。在使用<code>pthread_mutex_t</code>类型的变量前，必须由系统对其进行初始化，初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pthread_mutext* mutex-p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span>* attr-p 	</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用第二个参数，给这个参数赋值NULL即可。当一个Pthreads程序使用完互斥量后，它应该调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要获得临界区的访问权，线程需调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程退出临界区后，它应该调用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t* mutex_p)；</span><br></pre></td></tr></table></figure>

<p>调用<code>pthread_mutex_lock</code>会使线程等待，直到没有其他线程进入临界区；调用<code>pthread_mutex_unlock</code> 则通知系统该线程已经完成了临界区中代码的执行。</p>
<p>如果把线程数增加到超过核的个数，那么采用互斥量程序的性能仍然维持不变，但忙等待程序的性能就会下降。尽管忙等待总是浪费CPU的资源，但它是我们至今所知的，能事先确定线程执行临界区代码顺序的最适合方法：线程0最先执行，然后线程1，接下来线程2等。如果采用互斥量，那么哪个线程先进人临界区以及此后的顺序由系统随机选取。</p>
</li>
<li><p>信号量：信号量可以认为是一种特殊类型的unsigned int无符号整型变量，可以赋值为0、1、2、…。大多数情况下，只给它们赋值0和1，这种只有0和1值的信号量称为二元信号量。<br>信号量与互斥量最大的区别在于信号量是没有个体拥有权的，主线程将所有的信号量初始化为0，即“加锁”，其他线程都能对任何信号量调用<code>sem_post</code>和<code>sem_wait</code>函数。<br>不同信号量函数的语法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">sem_t</span>* semaphore_p, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> shared, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> initial_val</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用<code>sem_init</code>函数的第二个参数，对这个参数只需传人常数0即可。注意，信号量不是Pthreads线程库的一部分，所以需要在使用信号量的程序开头加头文件。</p>
</li>
<li><p>条件变量：它是一个数据对象，允许线程在某个特定条件或事件发生前都处于挂起状态。当事件或条件发生时，另一个线程可以通过信号来唤醒挂起的线程。一个条件变量总是与一个互斥量相关联。<br>Pthreads线程库中的条件变量类型为<code>pthread_cond_t</code>。函数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int pthread_cond_signal(pthread_cond_t* cond_var_p)；</span><br></pre></td></tr></table></figure>

<p>的作用是解锁一个阻塞的线程，而函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond_var_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>的作用是解锁所有被阻塞的线程。函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_cond_t</span>* cond_var_p,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_mutex_t</span>* mutex_p</span></span></span><br><span class="line"><span class="function"><span class="params">）；</span></span></span><br></pre></td></tr></table></figure>

<p>的作用是通过互斥量<code>mutex_p</code>来阻塞线程，直到其他线程调用<code>pthread_cond_signal</code>或者<code>pthread_cond_broadcast</code>来解锁它。当线程解锁后，它重新获得互斥量。所以实际上，<code>pthread_cond_wait</code>相当于按顺序执行了以下的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp; mutex_p); </span><br><span class="line">wait_on_signal(&amp; cond_var_p); </span><br><span class="line">pthread_mutex_lock(&amp; mutex_p):</span><br></pre></td></tr></table></figure>

<p>与互斥量和信号量一样，条件变量也应该初始化和销毁。对应的函数是</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_cond_t</span>* cond_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_cond_attr_t</span>* cond_attr_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">int pthread_cond_destroy(pthread_cond_t* cond_p)：</span><br></pre></td></tr></table></figure>

<p>我们一般不使用<code>pthread_cond_init</code>的第二个参数（调用函数时传递NULL作为参数值）。</p>
</li>
</ul>
<h2 id="3-实现读写锁"><a href="#3-实现读写锁" class="headerlink" title="3. 实现读写锁"></a>3. 实现读写锁</h2><p>读写锁实现方式有很多种，这里的是使用互斥量核条件变量来实现。</p>
<p>互斥量用于保护读写锁的数据：无论何时一个线程调用其中的任意一个函数（读锁、写锁、解锁），它必须首先锁互斥量，并且无论何时一个线程完成了这些函数调用中的一个，它必须解锁互斥量。在获取互斥量后，线程检查合适的数据成员来决定接下来干什么。例如，如果它想要进行读访问，就检查是否有一个写者当前拥有锁。如果没有，它对活动读者（即同时读的线程）的数量加1，然后继续执行随后的操作。如果有一个活动写者（有一个写者拥有锁，正在写），就为等待获取锁的读者的数量加1，并且在读者条件变量上启动一个条件等待。当它被条件唤醒后，它将正在等待的读者的数量减1，对活动读者的数量加1，并继续执行随后的操作。写锁函数的实现与读锁函数相类似。</p>
<p>解锁函数的操作取决于线程是一个读者还是一个写者。如果线程是一个读者，且没有其他的活动读者，并且一个写者正在等待，那么它就在返回前发送信号通知写者，使写者继续后继的操作。另一方面，如果线程是写者，则可能同时有读者和写者正在等待，因此线程需要决定它倾向于读者还是写者。因为写者必须互斥访问，很可能写者更难获得锁。因此，给予写者优先权。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rw_lock_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> NoOfReaders;	<span class="comment">// 读者数量</span></span><br><span class="line">    <span class="keyword">int</span> NoOfWriters, NoOfWritersWaiting;	<span class="comment">// 写者-等待数量</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> class_mutex;	<span class="comment">// 互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  reader_con;	<span class="comment">// 读者条件变量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  writer_con;	<span class="comment">// 写者条件变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 写-写 互斥</span></span><br><span class="line"><span class="comment">	* 写-读 互斥</span></span><br><span class="line"><span class="comment">	* 读-读 共享</span></span><br><span class="line"><span class="comment">	* 读-写 互斥</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">rw_lock_t</span>()</span><br><span class="line">    : NoOfReaders(<span class="number">0</span>), NoOfWriters(<span class="number">0</span>), NoOfWritersWating(<span class="number">0</span>),</span><br><span class="line">      class_mutex(PTHREAD_MUTEX_INITIALIZER),</span><br><span class="line">      reader_con(PTHREAD_COND_INITIALIZER),</span><br><span class="line">      writer_con(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">	<span class="comment">// 析构</span></span><br><span class="line">    ~<span class="keyword">rw_lock_t</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;class_mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;reader_con);</span><br><span class="line">        pthread_cond_destroy(&amp;writer_con);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        <span class="comment">//while(NoOfWriters&gt;0 || NoOfWritersWaiting&gt;0)	// 写者优先</span></span><br><span class="line">        <span class="keyword">while</span>(NoOfWriters&gt;<span class="number">0</span>)	</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;reader_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfReaders++;        </span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWritersWaiting++;</span><br><span class="line">        <span class="keyword">while</span>(NoOfReaders&gt;<span class="number">0</span> || NoOfWriters&gt;<span class="number">0</span>)	<span class="comment">// 锁被占用则等待</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;writer_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfWritersWaiting--; NoOfWriters++;</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfReaders--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfReaders==<span class="number">0</span> &amp;&amp; NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWriters--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        <span class="comment">//else	// 写者优先——直到没有写者才解锁读者</span></span><br><span class="line">        pthread_cond_broadcast(&amp;reader_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Pthread</tag>
      </tags>
  </entry>
</search>
