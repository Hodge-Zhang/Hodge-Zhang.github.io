<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo问题记录</title>
    <url>/2020/05/13/hexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>URL中有空格的话，在HTML中将会被截断，如下图的图片链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">The Elephant</span>](<span class="link">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The Elephant.jpg "大象群"</span>)</span><br></pre></td></tr></table></figure>

<p>![The Elephant](<a href="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The" target="_blank" rel="noopener">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The</a> Elephant.jpg “大象群”)</p>
<p>可以用<code>+</code>或者<code>%20</code>代替URL中的空格<code></code>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">The Elephant</span>](<span class="link">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The+Elephant.jpg "大象群"</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">The Elephant</span>](<span class="link">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The%20Elephant.jpg "大象群"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/The%20Elephant.jpg" alt="The Elephant" title="大象群"></p>
<p><a href="https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20" target="_blank" rel="noopener">更多关于URL中的空格的内容……</a></p>
<h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>执行<code>hexo g</code>生成静态网页时出错：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">YAMLException: end of the stream or a document separator is expected at line x, column y: ...</span></span><br></pre></td></tr></table></figure>

<p>原因：hexo <code>_posts</code>文件夹内的<code>.md</code>文件头部应该有一些头部<code>meta</code>信息来初始化一些配置的变量，这些信息在执行命令<code>hexo n filename</code>创建新的文章时会自动加上，但若直接从外部创建一个Markdown文件到<code>_posts</code>文件夹内，然后执行命令创建静态网页时就会因为得不到相关信息报以上的错误。</p>
<p>比如<code>diaspora</code>主题的头部信息为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: My awesome title</span><br><span class="line">date: 2020-1-12 18:38:45</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>分类1</span><br><span class="line"><span class="bullet">    - </span>分类2</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>标签1</span><br><span class="line"><span class="bullet">    - </span>标签2</span><br><span class="line">mp3: http://domain.com/awesome.mp3</span><br><span class="line">cover: http://domain.com/awesome-cover.png</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">更多关于hexo头部信息的内容……</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题diaspora</title>
    <url>/2020/05/13/hexo%E4%B8%BB%E9%A2%98diaspora/</url>
    <content><![CDATA[<p><strong><a href="http://fech.in" target="_blank" rel="noopener">在线预览 | PREVIEW </a></strong></p>
<p>一款基于WP移植的Hexo主题，适合喜欢摄影，影评，乐评和玩弄文字的你，干净，清新； 响应式，Ajax，更多好玩的等你来发现。 </p>
<blockquote>
<p>再次感谢原作者创作出这么精美的主题 <a href="https://github.com/LoeiFy/Diaspora">@Loeify</a> 。如果你喜欢，请捐助原作者。</p>
</blockquote>
<p><img src="https://fech.in/static/images/Diaspora.jpg" alt="cover"></p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Fechin/hexo-theme-diaspora.git themes/diaspora</span><br></pre></td></tr></table></figure>


<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改Hexo配置文件 <code>_config.yml</code> 主题项设置为diaspora</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">diaspora</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><p>注意：请在更时主题时备份<code>_config.yml</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/diaspora</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<h3 id="新建文章模板"><a href="#新建文章模板" class="headerlink" title="新建文章模板"></a>新建文章模板</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: My awesome title</span><br><span class="line">date: 2016-10-12 18:38:45</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>分类1</span><br><span class="line"><span class="bullet">    - </span>分类2</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>标签1</span><br><span class="line"><span class="bullet">    - </span>标签2</span><br><span class="line">mp3: http://domain.com/awesome.mp3</span><br><span class="line">cover: http://domain.com/awesome.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="创建分类页"><a href="#创建分类页" class="headerlink" title="创建分类页"></a>创建分类页</h3><p>1 新建一个页面，命名为 categories 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>2 编辑刚新建的页面，将页面的类型设置为 categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>主题将自动为这个页面显示所有分类。</p>
<h3 id="创建标签页"><a href="#创建标签页" class="headerlink" title="创建标签页"></a>创建标签页</h3><p>1 新建一个页面，命名为 tags 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>2 编辑刚新建的页面，将页面的类型设置为 tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>主题将自动为这个页面显示所有标签。</p>
<h3 id="创建搜索页"><a href="#创建搜索页" class="headerlink" title="创建搜索页"></a>创建搜索页</h3><p>1 需要安装hexo的搜索插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2 配置hexo全局配置文件（请将生成的索引文件放在网站根目录或修改主题js文件的path值）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>3 新建一个页面，命名为 search 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page search</span><br></pre></td></tr></table></figure>
<p>4 编辑刚新建的页面，将页面的类型设置为 search</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: search</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;search&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>5 在主题配置文件启用本地搜索</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地搜索,请将索引文件放在网站根目录</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="comment">#是否启用</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>主题将自动为这个页面显示搜索功能。</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头部菜单，title: link</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span>  </span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示目录</span></span><br><span class="line"><span class="attr">TOC:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否自动播放音乐</span></span><br><span class="line"><span class="attr">autoplay:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认音乐（随机播放）</span></span><br><span class="line"><span class="attr">mp3:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">http://link.hhtjim.com/163/425570952.mp3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">http://link.hhtjim.com/163/425570952.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首页封面图, 为空时取文章的cover作为封面(注意跨域问题,建议使用同源图片)</span></span><br><span class="line"><span class="attr">welcome_cover:</span> <span class="string">/img/welcome-cover.jpg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认文章封面图（随机调用,支持外链）</span></span><br><span class="line"><span class="attr">cover:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/img/cover.jpg</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/img/welcome-cover.jpg</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 是否关闭默认滚动条</span></span><br><span class="line"><span class="attr">scrollbar:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地搜索,请将索引文件放在网站根目录,或修改主题js文件的path值</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># 是否启用</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示 一言(hitokoto)</span></span><br><span class="line"><span class="attr">hitokoto:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接(可选:facebook,twitter,github,wechat,email)</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">    <span class="attr">facebook:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">twitter:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">wechat:</span> <span class="string">/img/logo.png</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">mailto:xxxx@gmail.com</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 备案</span></span><br><span class="line"><span class="attr">beian:</span> </span><br><span class="line">    <span class="comment"># 是否显示备案信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否在主页面最底下显示备案信息(虽然丑，但是完全满足规定要求)</span></span><br><span class="line">    <span class="attr">enableFooter:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 备案号</span></span><br><span class="line">    <span class="attr">beianInfo:</span> <span class="string">冀ICP备xxxxxxx号</span></span><br><span class="line">    <span class="comment"># 链接地址</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">http://www.beian.miit.gov.cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否使用mathjax</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitalk 评论插件（https://github.com/gitalk/gitalk）</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="comment"># 是否启用评论功能</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否自动展开评论框</span></span><br><span class="line">    <span class="attr">autoExpand:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 应用编号</span></span><br><span class="line">    <span class="attr">clientID:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># 应用秘钥</span></span><br><span class="line">    <span class="attr">clientSecret:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># issue仓库名</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Github名</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">''</span></span><br><span class="line">    <span class="comment"># Github名</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">['']</span></span><br><span class="line">    <span class="comment"># Ensure uniqueness and length less than 50</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">location.pathname</span></span><br><span class="line">    <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">    <span class="attr">distractionFreeMode:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站关键字</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Fechin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用google_analytics进行统计的话，这里需要配置ID</span></span><br><span class="line"><span class="attr">google_analytics:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站ico</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rss文件</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">atom.xml</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Diaspora</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 基础使用</title>
    <url>/2020/05/13/Markdown%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如今，不少内容发布者都使用Markdown 发布内容，而我昨天刚建的基于<code>hexo</code>的博客，也需要使用Markdown，鉴于最近才真正接触Markdown，所以在建站完成伊始先写篇博客总结下Markdown 的使用规则及技巧。</p>
<h2 id="1-Markdown简介"><a href="#1-Markdown简介" class="headerlink" title="1. Markdown简介"></a>1. Markdown简介</h2><p>Markdown是一种轻量级的<code>标记语言</code>，由John Gruber在2004年创建，其核心思想是格式与内容分离，这也符合今天网页的思想。它允许人们使用纯文本格式编写文档，使用Markdown编写的文档可以导出html、word、图像、pdf、epub 等多种格式的文档，常用来发布博客内容。Markdown 文档的后缀为<code>.md</code>或者<code>.markdown</code>。</p>
<h2 id="2-Markdown基础语法"><a href="#2-Markdown基础语法" class="headerlink" title="2. Markdown基础语法"></a>2. Markdown基础语法</h2><p>基础语法包括“标题”、“字体”、“列表”、“区块”，“代码”，“链接”，“图片”，“表格”这8大部分，能满足绝大多数文章的写作需求。</p>
<h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>共有6种级别的标题，用<code>#</code>标识，注意<code>#</code>与标题之间应有一个空格,接下来的内容也有注意区分语法中有无空格。一级标题后面会有一条分隔线。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>Markdown段落没有特殊的格式，直接编写文字即可。段落的换行是两个以上的空格+回车，当然也可以在段落后面直接使用一个空行表示重新开始一个段落。事实上，很多版本直接回车也是可以的。</p>
<p>Markdown的字体格式主要是“斜体”，“加粗”，此外还有一些格式如“下划线”，“删除线”，“分隔线”等。</p>
<p>下划线：实际上使用的是HTML里的<code>&lt;u&gt;</code>标签实现的。</p>
<p>删除线：文字两端分别加上两个波浪线<code>~</code>。</p>
<p>分隔线：在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西，也可以在星号或是减号中间插入空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本一*</span></span><br><span class="line"><span class="emphasis">_斜体文本二_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本一**</span></span><br><span class="line"><span class="strong">__粗体文本二__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">***粗斜体文本一**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本二__</span>_</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="bullet">- </span>- - - - -</span><br><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span> <span class="emphasis">* *</span> *</span><br><span class="line"></span><br><span class="line">~~删除线~~ </span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>斜体文本一</em><br><em>斜体文本二</em></p>
<p><strong>粗体文本一</strong><br><strong>粗体文本二</strong></p>
<p><strong><em>粗斜体文本一</em></strong><br><strong><em>粗斜体文本二</em></strong></p>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<hr>
<h3 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3 列表"></a>2.3 列表</h3><p>列表分有序列表和无须列表，前者使用形如<code>1.</code>直接标识，后者使用<code>*</code>、<code>+</code>或者<code>-</code>来标识。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-区块"><a href="#2-4-区块" class="headerlink" title="2.4 区块"></a>2.4 区块</h3><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code>符号 ，然后后面紧跟一个空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用1</span></span><br><span class="line"><span class="quote">&gt; 引用2</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line">&gt;&gt; 嵌套1</span><br><span class="line">&gt;&gt;&gt; 嵌套2</span><br><span class="line">&gt;&gt;&gt; - 第一项</span><br><span class="line">&gt;&gt;&gt; - 第二项</span><br><span class="line">&gt;&gt;&gt; - 第三项</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>最外层</p>
<blockquote>
<p>嵌套1</p>
<blockquote>
<p>嵌套2</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号`把它包起来，如果是代码块可以在其前后两行分别使用```来包裹，也可选择在前面指定编程语言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// your code is here</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-链接"><a href="#2-6-链接" class="headerlink" title="2.6 链接"></a>2.6 链接</h3><p>链接使用方法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">直接使用链接地址</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">[<span class="string">My Blob</span>](<span class="link">https://hodge-zhang.gitee.io/</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">hodge-zhang.github.io</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://hodge-zhang.gitee.io/" target="_blank" rel="noopener">My Blob</a></p>
<p><a href="https://hodge-zhang.github.io/" target="_blank" rel="noopener">https://hodge-zhang.github.io/</a></p>
<hr>
<h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><p>Markdown 图片语法格式如下：</p>
<ul>
<li>开头一个感叹号<code>！</code></li>
<li>接着一个方括号，里面放上图片无法加载时的替代文字，<code>[alt 属性文本]</code></li>
<li>最后是一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的<code>title</code> 属性的文字，(图片地址 “可选title”)</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">生命不息</span>](<span class="link">https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/bycle.jpg "生命"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/bycle.jpg" alt="生命不息" title="生命"></p>
<p>值得注意的是，Markdown写作的一个痛点就是图片的嵌入，它不像<code>.docx</code>那样文字与图片一起编码成一个独立的文件，Markdown是从外部通过统一资源定位符<code>URL</code>引入，这意味着带图片的Markdown文章要想在互联网上发布并被不同的人完整的看到，其图片必须在某个服务器上，由服务器来管理图片资源，管理图片的服务器就是图床了，目前我所使用的是阿里云的OSS自建的图床，从上面图片的链接中也可以看出来。关于图床的使用可以单独发出一篇文章来讲，这里就不多说了。</p>
<h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。同时我们也可以设置表格的对齐对齐方式：</p>
<ul>
<li><code>-:</code>设置内容和标题栏居右对齐。</li>
<li><code>:-</code> 设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">| :-----| :---: | ----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

<hr>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
</tbody></table>
<hr>
<p>从Markdown表格源码中可以看到使用Markdown制作表格比较麻烦的，实际写作过程中，像制作表格、绘制流程图、绘制时序图等一般借助第三方工具完成。</p>
<h2 id="3-Markdown-相关工具"><a href="#3-Markdown-相关工具" class="headerlink" title="3. Markdown 相关工具"></a>3. Markdown 相关工具</h2><p>作为一种使用了十几年的工具，基于Markdown也衍生出了很多的工具，这里只推荐我所使用的。</p>
<ul>
<li>编辑工具：<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，这篇文章即是使用这个工具写的，软件做的很棒，堪称优雅。</li>
<li>图片管理：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，功能齐全的图片管理工具，支持大多数图床，和Typora完美适配。</li>
<li>自建图床：<a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a>，作为国内商业化最好的云产品，40G OSS对象存储空间一年只需9RMB，是建立自己的云的不二之选了。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Pthread共享内存编程</title>
    <url>/2020/05/14/Pthreads%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要介绍下使用POSIX线程库，即Pthread在<code>共享内存系统</code>中进行多线程编程的基础范式，涉及的Pthread中的互斥量<code>pthread_mutex_t</code>、条件变量<code>pthread_cond_t</code>以及<code>&lt;semaphore.h&gt;</code>中的信号量的基础使用。主要参考Peter S.Pacheco所著的《An Introduction to Parallel Programming》。在正文开始之前，有必要回顾以下概念：</p>
<ul>
<li><code>共享内存系统</code>：共享内存系统中的任意处理器核都能够访问所有的内存区域。因此，协调各个处理器核工作的一个方法，就是把某个内存区域设为“共享”，这是并行编程中常见的方法。</li>
</ul>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F.jpg" alt="图1：共享内存系统"></p>
<ul>
<li><p><code>临界区</code>：对共享内存区域进行更新的代码段称为临界区。</p>
</li>
<li><p><code>进程</code>：进程是正在运行（或挂起）的程序的一个实例，由操作系统管理。它包括：</p>
<ol>
<li><p>代码段</p>
</li>
<li><p>栈段</p>
</li>
<li><p>堆段。</p>
</li>
<li><p>系统为进程分配的资源描述符，如文件描述符等。</p>
</li>
<li><p>安全信息，如进程允许访问的硬件和软件资源。</p>
</li>
<li><p>描述进程状态的信息，如进程是否准备运行或者正在等待某个资源，寄存器中的内容（包括程序计数器数值）等。</p>
</li>
</ol>
</li>
<li><p><code>线程</code>：它来自于“控制线程”的概念，控制线程是程序中的一个语句序列，也可以说是进程中的一个单一顺序的控制流，是cpu调度的基本单位。</p>
</li>
<li><p><code>缓存一致性</code>：指在采用层次结构存储系统的计算机系统中，cpu不同核的 catch中的数据与主存中的数据保持相同。为了达到缓存一致性的目的，出现了多种缓存一致性协议，常用的是<code>窥探（snooping）协议</code>。</p>
</li>
<li><p><code>伪共享</code>：线程并不共享任何东西（除了一个缓存行），但线程对内存访问的行为好像它们正在共享一个变量，因此把这种现象命名为伪共享。</p>
</li>
<li><p><code>线程安全</code>：如果一个代码块能够被多个线程同时执行而不引起问题，那么它是线程安全的。</p>
</li>
<li><p><code>互斥量(mutex)</code>：可以被看做是临界区的一把锁，它是一个特殊类型的变量，通过某些特殊类型的函数，互斥量可以用来限制每次只有一个线程能进入临界区，以保证对临界区的互斥 访问。</p>
</li>
<li><p><code>信号量(semaphore)</code>：是一个有两个操作（<code>sem_wait</code>和<code>sem_post</code>）的无符号型整数。如果信号量是正的，对<code>sem_wait</code>的调用就简单地将信号量减1；如果信号量是零，调用<code>sem_wait</code>的线程就会阻塞直到信号量为正数，此时信号量会减1，然后线程从调用中返回。<code>sem_post</code>操作使信号量加1。信号量比互斥量功能更强，因为它们能够初始化为任何非负值。而且，因为信号量没有“归属权”，任何线程都能够对锁上的信号量进行解锁。</p>
</li>
<li><p><code>条件变量(conditional variable)</code>：是一个特殊的线程对象，它用来挂起一个线程的执行直到某个条件发生。一旦条件发生，另一个线程能够用一个条件信号或一个条件广播唤醒挂起的线程。</p>
</li>
<li><p><code>路障(barrier)</code>是程序中的一个结点，线程必须阻塞直到所有的线程都到达了这个结点。路障另一个非常重要的应用是调试程序。</p>
</li>
</ul>
<h2 id="1-多线程的Hello-World"><a href="#1-多线程的Hello-World" class="headerlink" title="1. 多线程的Hello World"></a>1. 多线程的Hello World</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* File:  </span></span><br><span class="line"><span class="comment"> *    pth_hello.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> *    Illustrate basic use of pthreads:  create some threads,</span></span><br><span class="line"><span class="comment"> *    each of which prints a message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *    none</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *    message from each thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Compile:  gcc -g -Wall -o pth_hello pth_hello.c -lpthread</span></span><br><span class="line"><span class="comment"> * Usage:    ./pth_hello &lt;thread_count&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IPP:   Section 4.2 (p. 153 and ff.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variable:  accessible to all threads */</span></span><br><span class="line"><span class="keyword">int</span> thread_count;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span></span>;  <span class="comment">/* Thread function */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span>       thread;  <span class="comment">/* Use long in case of a 64-bit system */</span></span><br><span class="line">   <span class="keyword">pthread_t</span>* thread_handles; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Get number of threads from command line */</span></span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) Usage(argv[<span class="number">0</span>]);</span><br><span class="line">   thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);  </span><br><span class="line">   <span class="keyword">if</span> (thread_count &lt;= <span class="number">0</span> || thread_count &gt; MAX_THREADS) Usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   thread_handles = <span class="built_in">malloc</span> (thread_count*<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)  </span><br><span class="line">      pthread_create(&amp;thread_handles[thread], <span class="literal">NULL</span>,</span><br><span class="line">          Hello, (<span class="keyword">void</span>*) thread);  </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from the main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++) </span><br><span class="line">      pthread_join(thread_handles[thread], <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(thread_handles);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Hello</span><span class="params">(<span class="keyword">void</span>* rank)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> my_rank = (<span class="keyword">long</span>) rank;  <span class="comment">/* Use long in case of 64-bit system */</span> </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello from thread %ld of %d\n"</span>, my_rank, thread_count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  <span class="comment">/* Hello */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span>* prog_name)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;number of threads&gt;\n"</span>, prog_name);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"0 &lt; number of threads &lt;= %d\n"</span>, MAX_THREADS);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  <span class="comment">/* Usage */</span></span><br></pre></td></tr></table></figure>

<p>对以上程序的解读：</p>
<ol>
<li><p><code>pthread_t</code>数据结构用来存储线程的专有信息，它由<code>pthread.h</code>声明。要注意的是，<code>pthread_t</code>对象是一个不透明对象。对象中存储的数据都是系统绑定的，用户级代码无法直接访问到里面的数据。</p>
</li>
<li><p>下面是<code>pthread_create</code>函数的参数信息。<br>第一个参数是一个指针，指向对应的<code>pthread_t</code>对象。注意，<code>pthread_t</code>对象不是由<code>pthread_create</code>函数分配的，必须在调用<code>pthread_create</code>函数前就为<code>pthread_t</code>对象分配内存空间。<br>第二个参数一般不用，所以只是在函数调用时把NULL传递给参数。<br>第三个参数表示该线程将要运行的函数，下面会具体讲；<br>最后一个参数也是一个指针，指向传给函数start_routine的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	pthread.t* thread-p,			</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr_p,				</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span>* arg_p					</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由<code>pthread_create</code>生成并运行的函数应该有一个类似于下面函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span>* args_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为类型<code>void*</code>可以转换为C语言中任意指针类型，所以args_p可以指向一个列表，该列表包含一个或多个thread_function函数需要的数值。其返回值亦是如此。通常，参数列表里会传入一个int型<code>rank</code>参数，用于给线程显式的编号，以便于多线程代码的调试。注意，当线程结束时，由于它的函数的类型有一个返回值，那么线程就应该返回一个值。在本例中，线程没有需要特别返回的值，所以只返回NULL。</p>
</li>
<li><p><code>pthread_join</code>函数用于合并<code>pthread_create</code>创建的线程到主线程。第二个参数可以接收任意由<code>pthread_t</code>对象所关联的那个线程产生的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_t</span> thread,		</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ret_val_p			</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-临界区问题"><a href="#2-临界区问题" class="headerlink" title="2. 临界区问题"></a>2. 临界区问题</h2><p>共享内存的确使得多线程之间变量的共享变得方便了许多，但同时也带来了一个很大的问题：当多个线程尝试更新同一个共享变量时，会出问题。因此，多线程的程序应该保证一次只允许一个线程执行同一临界区的代码段。解决这个问题的方法主要有：</p>
<ul>
<li><p>忙等待：设置一个共享的int型变量flag，只有flag等于当前线程的rank时，当前线程才能访问临界区，否则忙等待，处于忙等待的线程仍然在持续使用CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag!=my_rank);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">临界区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">flag++;</span><br></pre></td></tr></table></figure>

<p>有时候编译器进行编译优化时为了充分利用寄存器，可能会将临界区代码提到while之前，这将导致忙等待失效，因此进行相关实验时关闭编译优化的选项是个好办法。</p>
</li>
<li><p>互斥量：Pthreads标准为互斥量提供了一个特殊类型：<code>pthread_mutex_t</code>。在使用<code>pthread_mutex_t</code>类型的变量前，必须由系统对其进行初始化，初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pthread_mutext* mutex-p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span>* attr-p 	</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用第二个参数，给这个参数赋值NULL即可。当一个Pthreads程序使用完互斥量后，它应该调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要获得临界区的访问权，线程需调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程退出临界区后，它应该调用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t* mutex_p)；</span><br></pre></td></tr></table></figure>

<p>调用<code>pthread_mutex_lock</code>会使线程等待，直到没有其他线程进入临界区；调用<code>pthread_mutex_unlock</code> 则通知系统该线程已经完成了临界区中代码的执行。</p>
<p>如果把线程数增加到超过核的个数，那么采用互斥量程序的性能仍然维持不变，但忙等待程序的性能就会下降。尽管忙等待总是浪费CPU的资源，但它是我们至今所知的，能事先确定线程执行临界区代码顺序的最适合方法：线程0最先执行，然后线程1，接下来线程2等。如果采用互斥量，那么哪个线程先进人临界区以及此后的顺序由系统随机选取。</p>
</li>
<li><p>信号量：信号量可以认为是一种特殊类型的unsigned int无符号整型变量，可以赋值为0、1、2、…。大多数情况下，只给它们赋值0和1，这种只有0和1值的信号量称为二元信号量。<br>信号量与互斥量最大的区别在于信号量是没有个体拥有权的，主线程将所有的信号量初始化为0，即“加锁”，其他线程都能对任何信号量调用<code>sem_post</code>和<code>sem_wait</code>函数。<br>不同信号量函数的语法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">sem_t</span>* semaphore_p, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> shared, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> initial_val</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们不使用<code>sem_init</code>函数的第二个参数，对这个参数只需传人常数0即可。注意，信号量不是Pthreads线程库的一部分，所以需要在使用信号量的程序开头加头文件。</p>
</li>
<li><p>条件变量：它是一个数据对象，允许线程在某个特定条件或事件发生前都处于挂起状态。当事件或条件发生时，另一个线程可以通过信号来唤醒挂起的线程。一个条件变量总是与一个互斥量相关联。<br>Pthreads线程库中的条件变量类型为<code>pthread_cond_t</code>。函数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int pthread_cond_signal(pthread_cond_t* cond_var_p)；</span><br></pre></td></tr></table></figure>

<p>的作用是解锁一个阻塞的线程，而函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond_var_p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>的作用是解锁所有被阻塞的线程。函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_cond_t</span>* cond_var_p,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_mutex_t</span>* mutex_p</span></span></span><br><span class="line"><span class="function"><span class="params">）；</span></span></span><br></pre></td></tr></table></figure>

<p>的作用是通过互斥量<code>mutex_p</code>来阻塞线程，直到其他线程调用<code>pthread_cond_signal</code>或者<code>pthread_cond_broadcast</code>来解锁它。当线程解锁后，它重新获得互斥量。所以实际上，<code>pthread_cond_wait</code>相当于按顺序执行了以下的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp; mutex_p); </span><br><span class="line">wait_on_signal(&amp; cond_var_p); </span><br><span class="line">pthread_mutex_lock(&amp; mutex_p):</span><br></pre></td></tr></table></figure>

<p>与互斥量和信号量一样，条件变量也应该初始化和销毁。对应的函数是</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_cond_t</span>* cond_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_cond_attr_t</span>* cond_attr_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">int pthread_cond_destroy(pthread_cond_t* cond_p)：</span><br></pre></td></tr></table></figure>

<p>我们一般不使用<code>pthread_cond_init</code>的第二个参数（调用函数时传递NULL作为参数值）。</p>
</li>
</ul>
<h2 id="3-实现读写锁"><a href="#3-实现读写锁" class="headerlink" title="3. 实现读写锁"></a>3. 实现读写锁</h2><p>读写锁实现方式有很多种，这里的是使用互斥量核条件变量来实现。</p>
<p>互斥量用于保护读写锁的数据：无论何时一个线程调用其中的任意一个函数（读锁、写锁、解锁），它必须首先锁互斥量，并且无论何时一个线程完成了这些函数调用中的一个，它必须解锁互斥量。在获取互斥量后，线程检查合适的数据成员来决定接下来干什么。例如，如果它想要进行读访问，就检查是否有一个写者当前拥有锁。如果没有，它对活动读者（即同时读的线程）的数量加1，然后继续执行随后的操作。如果有一个活动写者（有一个写者拥有锁，正在写），就为等待获取锁的读者的数量加1，并且在读者条件变量上启动一个条件等待。当它被条件唤醒后，它将正在等待的读者的数量减1，对活动读者的数量加1，并继续执行随后的操作。写锁函数的实现与读锁函数相类似。</p>
<p>解锁函数的操作取决于线程是一个读者还是一个写者。如果线程是一个读者，且没有其他的活动读者，并且一个写者正在等待，那么它就在返回前发送信号通知写者，使写者继续后继的操作。另一方面，如果线程是写者，则可能同时有读者和写者正在等待，因此线程需要决定它倾向于读者还是写者。因为写者必须互斥访问，很可能写者更难获得锁。因此，给予写者优先权。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rw_lock_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> NoOfReaders;	<span class="comment">// 读者数量</span></span><br><span class="line">    <span class="keyword">int</span> NoOfWriters, NoOfWritersWaiting;	<span class="comment">// 写者-等待数量</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> class_mutex;	<span class="comment">// 互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  reader_con;	<span class="comment">// 读者条件变量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  writer_con;	<span class="comment">// 写者条件变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 写-写 互斥</span></span><br><span class="line"><span class="comment">	* 写-读 互斥</span></span><br><span class="line"><span class="comment">	* 读-读 共享</span></span><br><span class="line"><span class="comment">	* 读-写 互斥</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造</span></span><br><span class="line">    <span class="keyword">rw_lock_t</span>()</span><br><span class="line">    : NoOfReaders(<span class="number">0</span>), NoOfWriters(<span class="number">0</span>), NoOfWritersWating(<span class="number">0</span>),</span><br><span class="line">      class_mutex(PTHREAD_MUTEX_INITIALIZER),</span><br><span class="line">      reader_con(PTHREAD_COND_INITIALIZER),</span><br><span class="line">      writer_con(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">	<span class="comment">// 析构</span></span><br><span class="line">    ~<span class="keyword">rw_lock_t</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;class_mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;reader_con);</span><br><span class="line">        pthread_cond_destroy(&amp;writer_con);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        <span class="comment">//while(NoOfWriters&gt;0 || NoOfWritersWaiting&gt;0)	// 写者优先</span></span><br><span class="line">        <span class="keyword">while</span>(NoOfWriters&gt;<span class="number">0</span>)	</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;reader_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfReaders++;        </span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWritersWaiting++;</span><br><span class="line">        <span class="keyword">while</span>(NoOfReaders&gt;<span class="number">0</span> || NoOfWriters&gt;<span class="number">0</span>)	<span class="comment">// 锁被占用则等待</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;writer_con, &amp;class_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        NoOfWritersWaiting--; NoOfWriters++;</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 读解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfReaders--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfReaders==<span class="number">0</span> &amp;&amp; NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">w_unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;class_mutex);</span><br><span class="line">        NoOfWriters--;</span><br><span class="line">        <span class="keyword">if</span>(NoOfWritersWaiting&gt;<span class="number">0</span>)</span><br><span class="line">            pthread_cond_signal(&amp;writer_con);</span><br><span class="line">        <span class="comment">//else	// 写者优先——直到没有写者才解锁读者</span></span><br><span class="line">        pthread_cond_broadcast(&amp;reader_con);</span><br><span class="line">        pthread_mutex_unlock(&amp;class_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 摘录</title>
    <url>/2020/05/16/Head-First-Java%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>与C++对比，学习Java，重点突出Java语言与C++相别的地方。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/deals-java-670x335.jpg" alt="deals-java-670x335"></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h4 id="1-1-问：其他程序语言可以直接用整数类型测试，我也可以像下面这么做吗？"><a href="#1-1-问：其他程序语言可以直接用整数类型测试，我也可以像下面这么做吗？" class="headerlink" title="1.1 问：其他程序语言可以直接用整数类型测试，我也可以像下面这么做吗？"></a>1.1 问：其他程序语言可以直接用整数类型测试，我也可以像下面这么做吗？</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：：不行，Java中的<code>integer</code>与<code>boolean</code>两种类型并不相容。你只能用下面这样的<code>boolean</code>变量来做条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Java源文件的声明规则"><a href="#1-2-Java源文件的声明规则" class="headerlink" title="1.2 Java源文件的声明规则"></a>1.2 Java源文件的声明规则</h4><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意以下规则：</p>
<ul>
<li>一个源文件中只能有一个public类</li>
<li>一个源文件可以有多个非public类</li>
<li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>
<li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p>
<h4 id="1-3-Java包-package"><a href="#1-3-Java包-package" class="headerlink" title="1.3 Java包(package)"></a>1.3 Java包(package)</h4><p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>
<h4 id="1-4-import-语句"><a href="#1-4-import-语句" class="headerlink" title="1.4 import 语句"></a>1.4 import 语句</h4><p>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<h4 id="1-5-Java-变量类型"><a href="#1-5-Java-变量类型" class="headerlink" title="1.5 Java 变量类型"></a>1.5 Java 变量类型</h4><p>Java语言支持的变量类型有：</p>
<ul>
<li><p>局部变量：类的方法中的变量。</p>
<ol>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ol>
</li>
<li><p>实例变量（成员变量）：独立于方法之外的变量，不过没有 static 修饰。  </p>
<ol>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：<em>ObejectReference.VariableName</em>。</li>
</ol>
</li>
<li><p>类变量（静态变量）：独立于方法之外的变量，用 static 修饰。</p>
<ol>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String strName;	<span class="comment">// 私有成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> staticVar;	<span class="comment">// 静态变量，默认初始化为0</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> staticVar2;	<span class="comment">// 公共的静态变量，默认初始化为0.0d</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]argv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span> localVar=<span class="number">99</span>;	<span class="comment">// 局部变量	System.out.println("val1:"+staticVar+"\nvar2:"+staticVar2);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-6-修饰符"><a href="#1-6-修饰符" class="headerlink" title="1.6 修饰符"></a>1.6 修饰符</h4><p>Java语言提供了很多修饰符，主要分为以下两类：</p>
<ul>
<li>访问修饰符<ol>
<li><strong>default</strong> (即默认，没有对应的关键字修饰）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ol>
</li>
<li>非访问修饰符<ol>
<li>static 修饰符，用来修饰类方法和类变量。</li>
<li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li>
<li>abstract 修饰符，用来创建抽象类和抽象方法。</li>
<li>synchronized 修饰符，synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li>
<li>transient 修饰符，序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li>
<li>volatile 修饰符，volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类(同一包)</th>
<th>子孙类(不同包)</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y/N</td>
<td>N</td>
</tr>
<tr>
<td><code>default</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td><code>private</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<p>protected 需要从以下两个点来分析说明：</p>
<ul>
<li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
</ul>
<h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>20个面试常见Linux命令</title>
    <url>/2020/05/19/20%E4%B8%AA%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>今天总结几个非常常用的Linux命令，其中有几个在面试中很可能问相关命令的原理，比如后台运行命令。希望对大家有所帮助，最好自己去尝试在Linux操作系统中实践一下。</p>
</blockquote>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/image-20200519165218219.png" alt="20个常用的Linux命令"></p>
<h2 id="1-查看目录以及权限"><a href="#1-查看目录以及权限" class="headerlink" title="1. 查看目录以及权限"></a>1. 查看目录以及权限</h2><blockquote>
<p>在 Linux 中，通常使用 <code>ls -l</code>列出，其中可以查看文件属性，所属用户组等较为详细的信息。下面详细解释从左到右每一列是什么意思</p>
</blockquote>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/image-20200519170311297.png" alt="image-20200519170311297"></p>
<p>第一列第一个字段：文件类型，后面9个字符是模式，其中分为三组，每一组三个字段。第一组为所属用户权限。第二组为所属组的权限。第三组为其他用户所属权限。其中r(read)代表可读，w(write)代表可写，e(execute)代表可执行。在后面的9个字符中，如果是字母说明有相应的权限，如果为”-“代表没有权限。举一个例子</p>
<p><code>-rw-r-r--</code>:此为普通文件，对于所属用户为可读可写不能执行，对于所属组仅仅可读，对于其他用户仅为读。</p>
<p>第二列 硬链接数目</p>
<blockquote>
<p>硬链接允许作用之一是允许一个文件拥有多个有效路径名，从而防止误删。但是只能在同一文件系统中的文件之间进行连接，不能对目录进行创建。</p>
</blockquote>
<p>第三列是所属用户，第四列为所属组，第五列为文件大小，第六列为文件被修改的时间，最后为文件名。其中使用<code>chown</code>改变所属用户，<code>chgrp</code>改变所属组。</p>
<h2 id="2-nohup-no-hang-up-不要挂起的意思"><a href="#2-nohup-no-hang-up-不要挂起的意思" class="headerlink" title="2. nohup(no hang up 不要挂起的意思)"></a>2. nohup(no hang up 不要挂起的意思)</h2><blockquote>
<p>这也是常用后台启动程序的常用方法，如果在交互命令行中运行程序，我们很容易就终止它。在交互环境下，我们的输出一般都会直接输出到当前界面，在后台启动的时候通常会定向到文件，那通常情况是下面这个命令。</p>
</blockquote>
<p><code>nohup command &gt;X.file 2 &gt;&amp;1 &amp;</code></p>
<blockquote>
<p>其中1表示标准输出。2表示文件标准错误输出。<code>2&gt;1&amp;</code>即将两者合并，但是合并到哪里，就是<code>X.file</code>.</p>
</blockquote>
<h2 id="3-查看进程"><a href="#3-查看进程" class="headerlink" title="3. 查看进程"></a>3. 查看进程</h2><blockquote>
<p>有的时候我们需要查看进程是否已经启动或者尝试终止进程。经常使用的命令为 <code>ps -ef---</code> 列出当前正在运行的程序，那如何定位我们想要查看的进程A，这个时候使用grep，即 <code>ps -ef| grep A</code> .</p>
</blockquote>
<h2 id="4-awk"><a href="#4-awk" class="headerlink" title="4. awk"></a>4. awk</h2><blockquote>
<p>如果文件是csv(a.csv)，按照”,”分割，需求为打印第一列和第二列</p>
</blockquote>
<p><code>awk -F &quot;,&quot; &#39;{print 2}&#39; a.csv</code></p>
<blockquote>
<p>获取第三列最大值</p>
</blockquote>
<p><code>awk &#39;BEGIN{max=0}{if(3&gt;max)max=3}END{print max}&#39;</code></p>
<h2 id="5-tar解压缩"><a href="#5-tar解压缩" class="headerlink" title="5. tar解压缩"></a>5. tar解压缩</h2><blockquote>
<p>解压缩命令</p>
</blockquote>
<p>常用参数</p>
<blockquote>
<p>-c:创建的tar文件<br>-x:解开tar文件<br>-t:列出tar文件中包含的文件信息<br>-r：附加新的文件到tar文件中</p>
</blockquote>
<p>常用命令组合</p>
<p><code>tar -xvf /home/a.tar</code> //打开tar打包文件<br><code>tar -zxvf /home/a.tar.gz</code> //解压以gzip压缩的文件<br><code>tar -jxvf /home/a.tar.bz2</code> //解压以bzip压缩的文件<br><code>tar -cvf /home/a.tar /home</code> 打包/home下所有文件</p>
<h2 id="6-scp"><a href="#6-scp" class="headerlink" title="6. scp"></a>6. scp</h2><blockquote>
<p>通过<code>scp</code>命令在多台服务器中的相互复制 传输文件。为了省下输入密码，可以设置免密登录。</p>
</blockquote>
<p>常用组合：</p>
<p>例子1：将A服务器中/home/a.txt 复制到B服务器的/home中</p>
<p><code>scp -r /home/a.txt root@B_ip:/home</code></p>
<h2 id="7-不敢用的命令-rm-rf"><a href="#7-不敢用的命令-rm-rf" class="headerlink" title="7. 不敢用的命令 rm -rf"></a>7. 不敢用的命令 rm -rf</h2><blockquote>
<p>保持清醒，慎用！</p>
</blockquote>
<h2 id="8-watch"><a href="#8-watch" class="headerlink" title="8. watch"></a>8. watch</h2><blockquote>
<p>这个命令是动态查看命令执行的结果。比如如果需要每隔一秒高亮显示网络连接数的变化情况。则 <code>watch -n 1 -d netstat -ant</code></p>
</blockquote>
<p>例子：每隔一秒高亮显示http连接数的变化情况</p>
<p><code>watch -n 1 -d &#39;pstree | grep http&#39;</code></p>
<p>例子:十秒一次输出系统的平均负载</p>
<p><code>watch -n 10 &#39;cat /proc/loadavg&#39;</code></p>
<h2 id="9-df"><a href="#9-df" class="headerlink" title="9. df"></a>9. df</h2><blockquote>
<p>查看磁盘大小</p>
</blockquote>
<p><code>df -h</code></p>
<h2 id="10-tcpdump"><a href="#10-tcpdump" class="headerlink" title="10. tcpdump"></a>10. tcpdump</h2><blockquote>
<p>和它类似的工具在windows中是wireshark，其采用底层库winpcap/libpcap实现。采用了bpf过滤机制。下面我们看看提供的不同参数的含义。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-n</td>
<td align="left">使用IP地址表示主机。使用数字表示端口</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">指定要监听的端口。如果为”-i any”表示住区所有网卡数据包</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">输出诸如ip数据包中的TTL更加详细的信息</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">不打印时间戳</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">显示以太网帧头部信息</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">仅仅抓取指定数量的数据包</td>
</tr>
<tr>
<td align="left">-x</td>
<td align="left">按照十六进制显示数据包内容</td>
</tr>
<tr>
<td align="left">-X</td>
<td align="left">不仅仅输出-x结果还输出十六进制对应的ASCII字符</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">设置抓包时的抓包长度</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">将输出结果定向到某个文件，一般为pcap后缀</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">从文件读取数据包并显示数字表示端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>-i</th>
<th>指定要监听的端口。如果为”-i any”表示住区所有网卡数据包</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>输出诸如ip数据包中的TTL更加详细的信息</td>
</tr>
<tr>
<td>-t</td>
<td>不打印时间戳</td>
</tr>
<tr>
<td>-e</td>
<td>显示以太网帧头部信息</td>
</tr>
<tr>
<td>-c</td>
<td>仅仅抓取指定数量的数据包</td>
</tr>
<tr>
<td>-x</td>
<td>按照十六进制显示数据包内容</td>
</tr>
<tr>
<td>-X</td>
<td>不仅仅输出-x结果还输出十六进制对应的ASCII字符</td>
</tr>
<tr>
<td>-s</td>
<td>设置抓包时的抓包长度</td>
</tr>
<tr>
<td>-w</td>
<td>将输出结果定向到某个文件，一般为pcap后缀</td>
</tr>
<tr>
<td>-r</td>
<td>从文件读取数据包并显示</td>
</tr>
</tbody></table>
<p>知道了相关参数，下面看几个案例</p>
<table>
<thead>
<tr>
<th align="left">执行任务</th>
<th align="left">执行命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">捕获特定网口数据包</td>
<td align="left"><code>tcpdump -i eth0</code></td>
</tr>
<tr>
<td align="left">捕获特定个数(1000)的包</td>
<td align="left"><code>tcpdump -c 1000 -i eth0</code></td>
</tr>
<tr>
<td align="left">将捕获的包保存到文件</td>
<td align="left"><code>tcpdump -w a.pcap -i eth0</code></td>
</tr>
<tr>
<td align="left">读取pcap格式的包</td>
<td align="left"><code>tcpdump -r a.pcap</code></td>
</tr>
<tr>
<td align="left">增加捕获包的时间戳</td>
<td align="left"><code>tcpdump -n -ttt -i eth0</code></td>
</tr>
<tr>
<td align="left">指定捕获包的协议类型</td>
<td align="left"><code>tcpdump -i eth0 arp</code></td>
</tr>
<tr>
<td align="left">捕获指定端口</td>
<td align="left"><code>tcpdump -i eth0 post 22</code></td>
</tr>
<tr>
<td align="left">捕获特定目标ip+port的包</td>
<td align="left"><code>tcpdump -i eth0 dst address and port 22</code></td>
</tr>
<tr>
<td align="left">捕获DNS请求和响应</td>
<td align="left"><code>tcpdump -i eth0 -s0 port 53</code></td>
</tr>
<tr>
<td align="left">匹配Http请求头</td>
<td align="left">`tcpdump -s 0 -v -n -l</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>将捕获的包保存到文件</th>
<th>tcpdump -w a.pcap -i eth0</th>
</tr>
</thead>
<tbody><tr>
<td>读取pcap格式的包</td>
<td><code>tcpdump -r a.pcap</code></td>
</tr>
<tr>
<td>增加捕获包的时间戳</td>
<td><code>tcpdump -n -ttt -i eth0</code></td>
</tr>
<tr>
<td>指定捕获包的协议类型</td>
<td><code>tcpdump -i eth0 arp</code></td>
</tr>
<tr>
<td>捕获指定端口</td>
<td><code>tcpdump -i eth0 post 22</code></td>
</tr>
<tr>
<td>捕获特定目标ip+port的包</td>
<td><code>tcpdump -i eth0 dst address and port 22</code></td>
</tr>
<tr>
<td>捕获DNS请求和响应</td>
<td><code>tcpdump -i eth0 -s0 port 53</code></td>
</tr>
<tr>
<td>匹配Http请求头</td>
<td>`tcpdump -s 0 -v -n -l</td>
</tr>
</tbody></table>
<h2 id="11-lsof"><a href="#11-lsof" class="headerlink" title="11. lsof"></a>11. lsof</h2><blockquote>
<p>列出当前系统打开的文件描述符工具。可以得知感兴趣的描述符是被哪些进程使用</p>
</blockquote>
<p>同样，我们看看相关参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i</td>
<td align="left">显示sokcet文件描述符</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">显示指定的命令打开的所有文件描述符</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">仅显示打开了目标文件描述符的进程pid</td>
</tr>
</tbody></table>
<p>老规矩，上几个例子</p>
<table>
<thead>
<tr>
<th align="left">执行任务</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">列出所有的网络链接</td>
<td align="left"><code>lsof -i</code></td>
</tr>
<tr>
<td align="left">列出所有udp的网络链接</td>
<td align="left"><code>lsof -i udp</code></td>
</tr>
<tr>
<td align="left">列出谁在使用某个端口</td>
<td align="left"><code>lsof -i :3306</code></td>
</tr>
<tr>
<td align="left">列出谁在使用特定的tcp端口</td>
<td align="left"><code>lsof -i tcp:80</code></td>
</tr>
<tr>
<td align="left">根据文件描述范围列出文件信息</td>
<td align="left"><code>lsof -d 2-3</code></td>
</tr>
</tbody></table>
<h2 id="12-nc"><a href="#12-nc" class="headerlink" title="12. nc"></a>12. nc</h2><blockquote>
<p>nc–&gt;“瑞士军刀”。不知大家在渗透过程中，拿了shell有没有使用nc搞点事儿。它用来快速构建网络链接。常用来调试客户端程序。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i</td>
<td align="left">设置数据包传送的时间间隔</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">以服务器方式运行。默认为客户端运行</td>
</tr>
<tr>
<td align="left">-k</td>
<td align="left">重复接受并处理某个端口上的所有链接</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">以客户端运行时强制其使用指定端口</td>
</tr>
<tr>
<td align="left">-C</td>
<td align="left">将CR和LF两个字符作为结束符</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">使用udp协议。默认tcp协议</td>
</tr>
<tr>
<td align="left">-X</td>
<td align="left">nc客户端余代理服务器通信时默认为socks5协议。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">扫描目标机器某个范围服务是否开启</td>
</tr>
</tbody></table>
<p>案例</p>
<table>
<thead>
<tr>
<th align="left">执行任务</th>
<th align="left">执行命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">扫描机器A端口号在30-40的服务</td>
<td align="left"><code>nc -z A 30-40</code></td>
</tr>
<tr>
<td align="left">连接服务器A 端口号为5000</td>
<td align="left"><code>nc -C A 5000</code></td>
</tr>
<tr>
<td align="left">传送文件</td>
<td align="left"><code>MachineA:nc -v -n ip portE:\a.exe</code></td>
</tr>
</tbody></table>
<h2 id="13-netstat"><a href="#13-netstat" class="headerlink" title="13. netstat"></a>13. netstat</h2><blockquote>
<p>netstat是一个网络信息统计工具。它可以得到网卡接口上全部了解，路由表信息，网卡接口信息等。通常在网络编程中我们用它来显示TCP连接以及状态信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-n</td>
<td align="left">使用IP地址表示主机</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">显示结果中包含监听的socket</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">仅显示TCP连接</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">显示路由信息</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">显示网卡接口数据流量</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">每隔1s输出一次</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">显示socket定时器的信息</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">显示socket所属的进程的PID和名字</td>
</tr>
</tbody></table>
<p>下面列举几个常用例子</p>
<table>
<thead>
<tr>
<th align="left">执行任务</th>
<th align="left">执行命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">列出所有连接</td>
<td align="left"><code>netstat -a</code></td>
</tr>
<tr>
<td align="left">只列出TCP或者UDP</td>
<td align="left"><code>netstat -at/netstat -au</code></td>
</tr>
<tr>
<td align="left">列出监听中的连接</td>
<td align="left"><code>netstat -tnl</code></td>
</tr>
<tr>
<td align="left">获取进程名、进程号以及用户 ID</td>
<td align="left"><code>nestat  -nlpt</code></td>
</tr>
<tr>
<td align="left">打印统计信息</td>
<td align="left"><code>netstat -s</code></td>
</tr>
<tr>
<td align="left">netstat持续输出</td>
<td align="left"><code>netstat -ct</code></td>
</tr>
<tr>
<td align="left">打印active状态的连接</td>
<td align="left">`netstat -atnp</td>
</tr>
<tr>
<td align="left">查看服务是否运行(npt)</td>
<td align="left">`netstat -aple</td>
</tr>
</tbody></table>
<h2 id="14-vmstat"><a href="#14-vmstat" class="headerlink" title="14. vmstat"></a>14. vmstat</h2><blockquote>
<p><code>vmstat</code>能够实时输出系统的进程信息，内存使用，<code>cpu</code>使用等资源的使用情况</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f</td>
<td align="left">显示系统自启动以来执行的fork次数</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">显示内存相关统计信息</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">显示磁盘相关统计信息</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">显示指定磁盘分区统计信息</td>
</tr>
<tr>
<td align="left">count</td>
<td align="left">采样次数。</td>
</tr>
</tbody></table>
<p>看一下vmstat都有哪些输出字段。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/image-20200519171508934.png" alt="image-20200519171508934"></p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">procs</td>
<td align="left">r表示等待运行的而进程数目。b表示处于不可中断睡眠状态的进程数目</td>
</tr>
<tr>
<td align="left">memory</td>
<td align="left">swpd：使用的虚拟内存量。free：空闲内存量。buff：用作缓冲区的内存量。cache：用作缓存的内存量。</td>
</tr>
<tr>
<td align="left">swap</td>
<td align="left">si：从磁盘换入的内存量（/s）。so：交换到磁盘的内存量（/s）。</td>
</tr>
<tr>
<td align="left">io</td>
<td align="left">bi：从块设备接收的块（blocks/s）。bo：发送到块设备的块（blocks/s）。</td>
</tr>
<tr>
<td align="left">system</td>
<td align="left">in：每秒中断的次数，包括时钟。cs：每秒上下文切换的次数。</td>
</tr>
</tbody></table>
<blockquote>
<p>这里注意哈，如果查看磁盘的更加详细信息，有另外iostat所得到的信息就更加详细哟</p>
</blockquote>
<h2 id="15-mpstat"><a href="#15-mpstat" class="headerlink" title="15. mpstat"></a>15. mpstat</h2><blockquote>
<p>能够实时监测多处理器系统中各个cpu的使用情况。这个命令的执行需要安装 <code>sysstat</code> ，在centos中执行 <code>yum install systat</code> 就好了。</p>
</blockquote>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/image-20200519171945630.png" alt="image-20200519171945630"></p>
<p>然后我们看看各个字段什么意思。</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpu</td>
<td align="left">表示当前条信息属于哪个cpu的数据</td>
</tr>
<tr>
<td align="left">%usr</td>
<td align="left">进程运行在用户空间所占cpu运行时间的比例</td>
</tr>
<tr>
<td align="left">%nice</td>
<td align="left">nice值为负的进程运行在用户空间的时间占cpu总运行时间的比例</td>
</tr>
<tr>
<td align="left">%iowait</td>
<td align="left">cpu等待磁盘操作的时间占cpu总运行时间的比例</td>
</tr>
<tr>
<td align="left">%irq</td>
<td align="left">cpu用于处理硬件中断时间占cpu总运行时间的比例</td>
</tr>
<tr>
<td align="left">%soft</td>
<td align="left">cpu用于处理软件中断的时间占cpu用运行时间的比例</td>
</tr>
<tr>
<td align="left">%steal</td>
<td align="left">一对虚拟cpu。当超级管理员在处理某个虚拟cpu时，另一个等待它处理完才能运行。这段等待时间表示为steal时间占总运行时间的比例</td>
</tr>
<tr>
<td align="left">%guest</td>
<td align="left">运行虚拟cpu时间占cpu总运行时间的比例</td>
</tr>
<tr>
<td align="left">%idle</td>
<td align="left">系统空闲时间占cpu总运行时间的比例</td>
</tr>
</tbody></table>
<h2 id="16-split"><a href="#16-split" class="headerlink" title="16. split"></a>16. split</h2><blockquote>
<p>将文件分割为数个。</p>
</blockquote>
<p><code>split -5 a.txt</code> //将a.txt每5行分割为一个文件</p>
<h2 id="17-wc-c-filename"><a href="#17-wc-c-filename" class="headerlink" title="17. wc -c +filename"></a>17. wc -c +filename</h2><blockquote>
<p>统计文件中单词的个数。</p>
</blockquote>
<h2 id="18-more-less"><a href="#18-more-less" class="headerlink" title="18. more/less"></a>18. more/less</h2><blockquote>
<p>一页一页显示，通过空白键显示下一页/上一页</p>
</blockquote>
<h2 id="19-head-tail"><a href="#19-head-tail" class="headerlink" title="19. head/tail"></a>19. head/tail</h2><blockquote>
<p>查看某文件前几行或者后几行</p>
</blockquote>
<h2 id="20-diff"><a href="#20-diff" class="headerlink" title="20. diff"></a>20. diff</h2><blockquote>
<p><code>diff -c file1 file2</code> //显示两个文件的差异</p>
</blockquote>
<p><em>以上文章来源于<code>我是程序员小贱</code>，部分内容有删改。</em></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计网TCP/UDP高频面试题</title>
    <url>/2020/05/20/%E8%AE%A1%E7%BD%91TCP-UDP%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h4><p><strong>1、UDP 和 TCP 的特点与区别</strong></p>
<p><strong>2、UDP 、TCP 首部格式</strong></p>
<p><strong>3、什么是TCP 的三次握手和四次挥手</strong></p>
<p><strong>4、TCP 的三次握手（为什么三次？）</strong></p>
<p><strong>5、TCP 的四次挥手（为什么四次？）</strong></p>
<p><strong>6、TCP 长连接和短连接的区别</strong></p>
<p><strong>7、TCP粘包、拆包及解决办法</strong></p>
<p><strong>8、TCP 可靠传输</strong></p>
<p><strong>9、TCP 滑动窗口</strong></p>
<p><strong>10、TCP 流量控制</strong></p>
<p><strong>11、TCP 拥塞控制</strong></p>
<p><strong>12、提高网络利用率</strong></p>
<hr>
<h4 id="前-言"><a href="#前-言" class="headerlink" title="前 言"></a>前 言</h4><p>TCP和UDP是传输层的两个协议，传输层提供了进程间的逻辑通信，对上层应用层屏蔽了下层网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/TCP_UDP_headers.jpg" alt="TCP_UDP_headers" title="TCP和UDP首部"></p>
<hr>
<h4 id="1、UDP-和-TCP-的特点与区别"><a href="#1、UDP-和-TCP-的特点与区别" class="headerlink" title="1、UDP 和 TCP 的特点与区别"></a>1、UDP 和 TCP 的特点与区别</h4><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p>
<p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p>
<p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
<h4 id="2、UDP-、TCP-首部格式"><a href="#2、UDP-、TCP-首部格式" class="headerlink" title="2、UDP 、TCP 首部格式"></a>2、UDP 、TCP 首部格式</h4><p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/udp-header.jpg" alt="udp-header" title="UDP首部"></p>
<p>UDP 首部字段只有 8 个字节，包括源端口(Source Port)、目的端口(Destination Port)、长度(UDP Lengh)、校验和(UDP Checksum)。12 字节的伪首部是为了计算校验和临时添加的。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp-header.jpg" alt="tcp-header" title="TCP首部"></p>
<p>TCP 首部格式比 UDP 复杂。</p>
<p><strong><code>序号(Sequence Number)</code>：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p><strong><code>确认号(Acknowledgement Number)</code>：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p><strong><code>数据偏移(Data Offset, 有的也称之为首部长度Header Length)</code>：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
<p><strong><code>保留位(Reserved)</code>：</strong>保留给未来使用，必须为零。</p>
<p><strong><code>控制位(Control bits)</code>：</strong>共6位，从左到右分别是 URG，ACK，PSH，RST，SYN，FIN。</p>
<p><strong><code>URG</code>：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p>
<p><strong><code>ACK</code>：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p>
<p><strong><code>PSH</code>：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p>
<p><strong><code>RST</code>：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p>
<p><strong><code>SYN</code>：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p>
<p><strong><code>FIN</code>：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p>
<p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p>
<p><strong><code>窗口大小(Window size)</code>：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<p><a href="https://www.freesoft.org/CIE/Course/Section4/8.htm" target="_blank" rel="noopener">TCP首部格式参考</a></p>
<h4 id="3、什么是-TCP-的三次握手和四次挥手？"><a href="#3、什么是-TCP-的三次握手和四次挥手？" class="headerlink" title="3、什么是 TCP 的三次握手和四次挥手？"></a>3、什么是 TCP 的三次握手和四次挥手？</h4><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p>
<p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>
<p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接；采用四次挥手来关闭一个连接。</p>
<p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p>
<p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会（提供网络利用率这部分有讲到）。</p>
<p>ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p>
<p><strong>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。</strong>给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</p>
<p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而IP 不提供重复消除或者保证次序正确的功能。</p>
<p>另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>
<h4 id="4、TCP-的三次握手（为什么三次？）"><a href="#4、TCP-的三次握手（为什么三次？）" class="headerlink" title="4、TCP 的三次握手（为什么三次？）"></a>4、TCP 的三次握手（为什么三次？）</h4><p>三次握手：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+build+link.jpg" alt="tcp-build-link" title="TCP三次握手建立连接"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
<ul>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
</ul>
<p>B 收到 A 的确认后，连接建立。</p>
<p><strong>为什么是三次？</strong></p>
<p>1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>2、换个易于理解的视角来看为什么要 3 次握手。</p>
<p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</p>
<p>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<p><strong>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</strong></p>
<p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</p>
<p>其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。</p>
<p>比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>
<h4 id="5、TCP-的四次挥手（为什么四次？）"><a href="#5、TCP-的四次挥手（为什么四次？）" class="headerlink" title="5、TCP 的四次挥手（为什么四次？）"></a>5、TCP 的四次挥手（为什么四次？）</h4><p>四次挥手：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+finish+link.jpg" alt="tcp-finish-link" title="TCP四次挥手结束连接"></p>
<ul>
<li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li>
<li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li>
<li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li>
<li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li>
</ul>
<p><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></p>
<p>1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。</p>
<p>2、这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</p>
<p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<p>3、客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p>4、因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h4 id="6、TCP-短连接和长连接的区别"><a href="#6、TCP-短连接和长连接的区别" class="headerlink" title="6、TCP 短连接和长连接的区别"></a>6、TCP 短连接和长连接的区别</h4><p><strong>短连接：</strong>Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。</p>
<p>短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。</p>
<p><strong>长连接：</strong>Client  Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。</p>
<p>长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。</p>
<h4 id="7、TCP粘包、拆包及解决办法"><a href="#7、TCP粘包、拆包及解决办法" class="headerlink" title="7、TCP粘包、拆包及解决办法"></a>7、TCP粘包、拆包及解决办法</h4><p><strong>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</strong></p>
<p>由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p>
<p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p>
<p><strong>什么是粘包、拆包？</strong></p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.png" alt="tcp粘包拆包" title="TCP粘包拆包"></p>
<p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p>
<p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+pk.png" alt="tcp-pk" title="正常发送"></p>
<p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+pk1.png" alt="tcp-pk1" title="粘包"></p>
<p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+pk2.png" alt="tcp-pk2" title="拆包Packet1"></p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp+pk3.png" alt="tcp-pk3" title="拆包Packet2"></p>
<p><strong>为什么会发生 TCP 粘包、拆包？</strong></p>
<ul>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li>
</ul>
<p><strong>粘包、拆包解决办法</strong></p>
<p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p>
<ul>
<li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li>
<li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li>
<li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li>
<li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li>
</ul>
<h4 id="8、TCP-可靠传输"><a href="#8、TCP-可靠传输" class="headerlink" title="8、TCP 可靠传输"></a>8、TCP 可靠传输</h4><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/rtt-formula.png" alt="rtt-formula"></p>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/rto-formula.png" alt="rto-formula"></p>
<p>其中 RTTd 为偏差的加权平均值。</p>
<h4 id="9、TCP-滑动窗口"><a href="#9、TCP-滑动窗口" class="headerlink" title="9、TCP 滑动窗口"></a>9、TCP 滑动窗口</h4><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp-slide.jpg" alt="tcp-slide" title="TCP滑动窗口机制"></p>
<h4 id="10、TCP-流量控制"><a href="#10、TCP-流量控制" class="headerlink" title="10、TCP 流量控制"></a>10、TCP 流量控制</h4><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>实际上，<strong>为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段</strong>，此数据段仅包含一个字节来获取最新的窗口大小信息。</p>
<h4 id="11、TCP-拥塞控制"><a href="#11、TCP-拥塞控制" class="headerlink" title="11、TCP 拥塞控制"></a>11、TCP 拥塞控制</h4><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="tcp拥塞控制" title="TCP拥塞控制"></p>
<p>TCP 主要通过四个算法来进行拥塞控制：</p>
<p><strong>慢开始、拥塞避免、快重传、快恢复。</strong></p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.jpg" alt="tcp拥塞控制2" title="TCP拥塞控制"></p>
<p><strong>慢开始与拥塞避免</strong></p>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<p><strong>快重传与快恢复</strong></p>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/tcp%E5%BF%AB%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6.jpg" alt="tcp快重传机制" title="快重传机制"></p>
<h4 id="12、提高网络利用率"><a href="#12、提高网络利用率" class="headerlink" title="12、提高网络利用率"></a>12、提高网络利用率</h4><p><strong>1、Nagle 算法</strong></p>
<p>发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。</p>
<ul>
<li>已发送的数据都已经收到确认应答。</li>
<li>可以发送最大段长度的数据时。</li>
</ul>
<p><strong>2、延迟确认应答</strong></p>
<p>接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。</p>
<ul>
<li>在没有收到 2*最大段长度的数据为止不做确认应答。</li>
<li>其他情况下，最大延迟 0.5秒 发送确认应答。</li>
<li>TCP 文件传输中，大多数是每两个数据段返回一次确认应答。</li>
</ul>
<p><strong>3、捎带应答</strong></p>
<p>在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>文摘2020</title>
    <url>/2020/05/22/%E6%96%87%E6%91%982020/</url>
    <content><![CDATA[<p>1、<a href="https://zh.wikipedia.org/wiki/哲学剃刀" target="_blank" rel="noopener">哲学剃刀</a></p>
<p>“剃刀”（razor）这个词，在哲学里面有特殊含义，指的是一种经验法则，可以对某种现象做出简洁的解释，消除了其他的解释。</p>
<p>常常被引用的”剃刀”（经验法则）有下面这些。</p>
<p><strong>奥卡姆剃刀</strong>：更简单的解释更可能是正确的。引申为某个命题成立，所需要的假设越少越好。</p>
<p><strong>汉隆剃刀</strong>：永远不要将恶意归咎于愚蠢。</p>
<p><strong>希钦斯剃刀</strong>：凡是无证据的断言，也可以无证据地驳回。</p>
<p><strong>休谟剃刀</strong>：从一样东西是什么，无法推导出它应该是什么，即无法从事实推导出价值判断。</p>
<p><strong>牛顿剃刀</strong>：无法通过实验或观察解决的问题，不值得争论。</p>
<p><strong>萨根标准</strong>：非同寻常的主张，需要非同寻常的证据。</p>
<p><strong>波普原则</strong>：一个理论被认为是正确的，前提必须是有可能证明它是错误的，即必须是可证伪的。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/book_high.jpg" alt="about-book" title="以书为阶"></p>
]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>Digest</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2020/05/23/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要介绍Git这一版本控制工具的基本使用，重点熟悉<code>Git Bash</code>下的命令。</p>
<h3 id="1-Git的诞生"><a href="#1-Git的诞生" class="headerlink" title="1. Git的诞生"></a>1. Git的诞生</h3><blockquote>
<p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
</blockquote>
<p>来源：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202815778784" target="_blank" rel="noopener">Git的诞生</a></p>
<h3 id="2-Git的安装"><a href="#2-Git的安装" class="headerlink" title="2. Git的安装"></a>2. Git的安装</h3><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<h4 id="2-1-Linux-下的安装"><a href="#2-1-Linux-下的安装" class="headerlink" title="2.1 Linux 下的安装"></a>2.1 Linux 下的安装</h4><p>首先，你可以在终端<code>terminal</code>中试着输入<code>git</code>，看看系统有没有安装Git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program <span class="string">'git'</span> is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git，如果你使用的是Debian或Ubuntu Linux，通过命令：<code>sudo apt-get install git</code> 就可以直接安装，其他Linux发布的版本大同小异。</p>
<h4 id="2-2-Windows-下的安装"><a href="#2-2-Windows-下的安装" class="headerlink" title="2.2 Windows 下的安装"></a>2.2 Windows 下的安装</h4><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。</p>
<p>安装完成后，你可能会看到三个Git可执行程序：<code>Git Bash</code>, <code>Git CMD</code>, <code>Git GUI</code>，它们的功能基本相同，我们一般用的最多的是<code>Git Bash</code>，另外两个就因人而异了。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/image-20200522233537387.png" alt="image-20200522233537387" title="Win10下的Git Bash"></p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="3-Git的原理"><a href="#3-Git的原理" class="headerlink" title="3. Git的原理"></a>3. Git的原理</h3><p>在正式开始学习Git的命令之前，你需要首先明白Git大致的工作原理：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/git-reasons.png" alt="git-Working-Mechanism" title="Git原理"></p>
<p>对应的中文图示：</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/git-linux.png" alt="git-Working-Mechanism" title="Git原理"></p>
<p>其中：</p>
<ul>
<li><p><strong>Workspace</strong>：工作区，是你平时存放项目代码的文件夹。</p>
</li>
<li><p><strong>Index / Stage</strong>：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p>
</li>
<li><p><strong>Repository</strong>：本地仓库，即.git目录。就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中.git/HEAD指向最新放入仓库的版本。.git目录下还有很多文件，它们的作用可以看*<a href="https://www.mscto.com/pm/231939.html" target="_blank" rel="noopener">这里</a>*。</p>
</li>
<li><p><strong>Remote</strong>：远程仓库，托管代码的服务器，最常用的如github，当然你也可以自己配置远程仓库。</p>
</li>
</ul>
<p>Git的工作流程一般是这样的：</p>
<ol>
<li><p>在工作目录中添加、修改文件；</p>
</li>
<li><p>将需要进行版本管理的文件放入暂存区域；</p>
</li>
<li><p>将暂存区域的文件提交到Git仓库。</p>
</li>
</ol>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)。</p>
<p>工作区的文件有四种状态：</p>
<ul>
<li><p><strong>Untracked:</strong>  未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为Staged.</p>
</li>
<li><p><strong>Unmodify:</strong>  文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified。如果使用<code>git rm</code>移出版本库, 则成为Untracked文件.</p>
</li>
<li><p><strong>Modified:</strong> 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存staged状态, 使用<code>git checkout</code>则丢弃修改过, 返回到unmodify状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改.</p>
</li>
<li><p><strong>Staged:</strong> 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致. 文件为Unmodify状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为Modified.</p>
<p>下面的图很好的解释了这四种状态的转变：</p>
</li>
</ul>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/git-file-status.png" alt="git-file-status" title="文件状态的转换"></p>
<p>以上内容只是为了帮助你更好地理解Git的命令真正的含义，一时不太明白没有关系，可以通过命令来实践。</p>
<h3 id="4-Git常用命令"><a href="#4-Git常用命令" class="headerlink" title="4. Git常用命令"></a>4. Git常用命令</h3><p>接下来的内容只是简单地罗列了下常用的命令及其功能，只看并不能学习到任何东西，一定要亲手建立个代码库把这些命令尝试一遍。</p>
<h4 id="4-1-新建代码库"><a href="#4-1-新建代码库" class="headerlink" title="4.1 新建代码库"></a>4.1 新建代码库</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于某些原因，<code>git clone</code>克隆远程仓库到本地时可能只有十几k的速度，甚至连github.com都ping不通，对于比较大的仓库，极有可能在下载过程中因超时而中断。这时一种普遍的方式是使用代理；这种方式个体差异性很大，因此这里主要说下第二种方式：使用github的镜像网站<a href="https://github.com.cnpmjs.org/" target="_blank" rel="noopener">github.com.cnpmjs.org</a> 把url中的github.com替换掉，这种方式能提速10-100倍。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Hodge-Zhang/hexo-theme-diaspora</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为：</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com.cnpmjs.org/Hodge-Zhang/hexo-theme-diaspora</span><br></pre></td></tr></table></figure>

<h4 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h4><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前/全局的Git配置</span></span><br><span class="line">$ git config --list [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-3-增加-删除文件"><a href="#2-3-增加-删除文件" class="headerlink" title="2.3 增加/删除文件"></a>2.3 增加/删除文件</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将该文件从暂存区移除，停止追踪，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-4-代码提交"><a href="#2-4-代码提交" class="headerlink" title="2.4 代码提交"></a>2.4 代码提交</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到本地仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到本地仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-5-分支"><a href="#2-5-分支" class="headerlink" title="2.5 分支"></a>2.5 分支</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-6-标签"><a href="#2-6-标签" class="headerlink" title="2.6 标签"></a>2.6 标签</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-7-查看信息"><a href="#2-7-查看信息" class="headerlink" title="2.7 查看信息"></a>2.7 查看信息</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-8-远程同步"><a href="#2-8-远程同步" class="headerlink" title="2.8 远程同步"></a>2.8 远程同步</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-9-撤销"><a href="#2-9-撤销" class="headerlink" title="2.9 撤销"></a>2.9 撤销</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-10-其他"><a href="#2-10-其他" class="headerlink" title="2.10 其他"></a>2.10 其他</h4><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>有生之年，这个时代最大的三个问题——Ray·Dalio</title>
    <url>/2020/06/10/%E6%9C%89%E7%94%9F%E4%B9%8B%E5%B9%B4%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E4%BB%A3%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Ray%C2%B7Dalio/</url>
    <content><![CDATA[<p>  <code>本文整理自桥水基金创始人瑞·达利欧(Ray·Dalio)6月8日在中国发展高层论坛首期节目中的发言.</code></p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/ray_dalio.webp" alt="img" title="Ray·Dalio"></p>
<h3 id="当今世界的三个大问题"><a href="#当今世界的三个大问题" class="headerlink" title="当今世界的三个大问题"></a>当今世界的三个大问题</h3><p>虽然直接谈论目前的状况很有诱惑力，但是我想先尽量拒绝这样的诱惑，先退一步从大的背景上来谈。我是1949年出生的，正好是中华人民共和国成立的那年，我在美国长大，生长于美国主导的世界秩序中，那时美元是全球最主要的储备货币，现在依然是。新的世界秩序，也就是我们现在所熟悉的世界秩序，实际是1945年以后建立的。1944年布雷顿森林协议签订，1945年新秩序在战争和破坏的时期结束后诞生，但是我本身没有并经历过那个时期。</p>
<p>在我的职业生涯当中，有很多让我感到惊讶的事情，我都不曾亲身经历过，所以我需要学习历史。我在1971年的时候明白了这一点，当时我刚本科毕业，准备读研究生之前的那个暑期我在纽约证券交易所的交易大厅工作。当时，美元不被世界接受，和黄金的联系也摇摇欲坠。在1971年8月15日，尼克松向世界宣布，美国不会再支持用美元纸币兑换黄金，切断黄金和美元的关系。我走进纽约证交所的交易大厅，以为局面肯定会非常混乱。我本来预期股市会大跌，但是令我感到惊讶的是，股市反而涨了4%，那是几十年来涨得最多的一次。</p>
<p>由于之前没有经历过货币贬值，所以我去研究了历史，然后发现历史上发生过很多次货币贬值，也知道了为什么货币贬值会导致股市上升。这也是我第一次经历之前人生从未经历过的重大事件，这使我认识到了解在出生之前发生的事情，就不会感到措手不及。所以，我今天也想谈谈这类事情。</p>
<p>近期，在疫情发生之前，我正在进行这样的观察，当时已经出现了一些趋势，在我的有生之年是没有发生过的。</p>
<blockquote>
<p>The Three Big Issues</p>
<blockquote>
<ol>
<li><p>End of long term debt cycle</p>
</li>
<li><p>Wealth and political gaps</p>
</li>
<li><p>The rise of a great power (China) to challenge the existing great Power </p>
</li>
</ol>
</blockquote>
</blockquote>
<p>这三个大问题依然是这个时代最大的三个问题。第一个，我们已经走到了长期债务周期的末尾，也就是说，这个债务周期是在1945年开始的，这个周期里面创造了大量的信贷。通常是通过债务重组，又开始积累新的债务，然后给央行创造货币和信贷的权力。一旦经济走弱，央行就开始印钞票，扩大信贷，这样市场又被托起来了。央行可以一直这样做直到利率达到零，当利率达到接近零的时候，就很难再通过同样的方式去刺激经济了。所以，当2008年利率下降到零时，政府不得不印钞，购买金融资产，将金融资产注入市场。这对整个市场产生了巨大的影响，上次发生这样的事情是在1933年，所以规律就逐渐显现了。 </p>
<p>现在和1930—1945年期间的情况非常相似，我等一会再讲这部分内容。<strong>还有一个趋势是比较大的贫富差距，是非常不公平的经济差异，不是失去平等机会之类的。这在我有生之年没有发生过</strong>，但是在1930—1945年期间有发生。然后有了大国的崛起，即中国挑战这个秩序中的现有主导大国美国的地位，这在之前也没有发生过。尽管之前有苏联，但是从经济体量上来说，并不是非常强大有力的对手。</p>
<p>我一直在观察这些，以及相应的反应上的变化。过去35年我一直在中国，中国建国以来的一半时间与我人生的一半时间是重叠的，我也见证了这个时期的变化，见证了刚才讲到的经济方面的差异。我想知道1930—1945年间发生了什么。我决定要深入研究一下，我需要去理解这些储备货币的崛起和衰退，以及它们背后的帝国的兴衰。所以，我去看了其他储备货币和帝国兴衰，请通过图表了解一下。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/1_the_long_term_debt_cycle.webp" alt="img" title="Debt Cycle"></p>
<p>这里展示的是过去大概100年的情况，图表显示了美国的债务占GDP的比例。在第一组圆圈里，在1930年左右，当时有非常多的债务和债务危机，蓝线显示利率趋于0，红线显示的是印钞和央行购入金融资产。可以看到，在这个时期中，之前并没有发生过这样的事。而2008年基本重复了当时的情形，利率趋于0，印钞以刺激经济。在1933年3月5号，罗斯福总统切断了和黄金的挂钩，并大量印钞，就像尼克松1971年8月15号做的一样，也类似今年4月9号美联储和财政部的举措。换言之，就是决定大量印钞、创造信贷来解决眼前的问题。</p>
<p>下一张图展示的是贫富差距。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/3_the_wealth_and_income_gaps.webp" alt="img" title="Gaps"></p>
<p>左边是净财富角度，右边是收入角度。<strong>目前，顶部0.1%的最富有的这些美国人，他们的净财富接近于底部90%人群的财富总和，目前的贫富差距是自30年代以来的最高点。</strong>在右边可以看到收入的差距，类似的我们可以看到头部10%的跟底部90%的大致相当，贫富差距的问题引发了民粹主义。</p>
<p>虽然这是美国的图表，实际上在世界其他国家也是非常适用的。贫富和收入差距，也在一定程度上引发了政治方面的问题。在我们的有生之年，可能还没有亲身经历过，可能要追溯更久远才会发现有相似的时期。</p>
<p>接下来的这张图，蓝线代表民主党，红线代表共和党。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/2_the_political_split_is_the_greatest_since_1900.webp" alt="img"></p>
<p>线越高代表经济上越保守，线越低代表在经济上越自由。自1900年起差距变大，到了前所未有的程度。此图下面这条线显示的是国会议员的投票，即95%的投票是根据党派决定的，所以在美国有一个非常大的政治分歧，这个分歧现在已经达到了最顶峰。这样的经济政策、政治政策都和财富的再分配、资本主义等等都有关，对经济和市场的表现造成深远影响。比如，降低公司所得税可以刺激股价上升，因为市值会增加。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/4_the_rises_and_declines_of_empires.webp" alt="img"></p>
<p>这张图表展现的是帝国国力的兴衰，是从1500年到现在的一个追踪，是8种实力的汇总。可以看到，从1500到现在最重要的一些大国的相对实力，红线是中国，在这个时期，明朝的时候达到了最高点，跟当时的欧洲相比还是强很多，绿色这条线是西班牙帝国，他们之前都是主导大国。橘线表示荷兰帝国的追赶，大概在1600年左右，荷兰帝国变得像西班牙帝国一样强大，世界格局发生了变化。通过橘线我们可以看到，这样的格局大概有100多年，持续到1780年，然后黑线所代表的大英帝国开始超越荷兰。当时是有英荷的大战，荷兰帝国落败，也终止了荷兰当时的储备货币地位。然后开始了大英帝国的统治，从这之后大概又是一百年的时间，黑线代表的大英帝国处于主导地位。之后是蓝线，蓝线就是美利坚帝国的崛起，我们可以看到它的上扬。然后进入二战，美国、英国是盟军，同时崛起。</p>
<p>如果仔细看的话，可以看到日、德，这两个大国崛起，大国崛起后，又有了一次大战。在这场大战终结的时候，新的世界秩序建立。我们已经习惯于这样的秩序了，也并不太了解在此之前所发生的事。我们现在可以看到，红线代表的中国，在大概1949年、1950年的时候，从低点开始崛起，我得以近距离地见证并参与中国在这个时期的崛起。</p>
<p>我35年前来到中国，所以我的一半人生和中国崛起的大半时间都是交织在一起的。<strong>我目睹了中国的人均收入增加了22倍，贫困率从88%下降到不到1%，中国GDP占世界的比重从2%上升到了22%的过程。</strong>我接触并了解过最穷的、最富的、最成功、最有权势的、最谦虚的中国人。我也逐渐对中国文化有了一定的理解，所以，我从历史的角度着眼当前世界的状况。</p>
<p>我对中美文化都有一定了解，我发现自己处于它们中间。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/5_the_rises_and_declines.webp" alt="img"></p>
<p>这张图是刚才提到的三个帝国的简化版本，橘色代表荷兰，黑线是英国，蓝线是美国，红线象征中国的崛起，灰色区域是比较痛苦的历史过渡期，因为它们是在长期债务周期的后期，而债务周期后期有比较大的贫富差距，内部的冲突非常激烈，可能还伴随着国内革命。这些革命可能是和平式的，也可能是暴力式的。比如，在1930年左右，美国发生了经济革命，应该说是比较和平的，它带来了财富的转移，对经济体系产生了重要的影响。当然这种革命也可能是暴力的，比如说1933年的时候在德国，希特勒上台执政，当时有内部暴力冲突，于是德国建立了维持秩序的体系。在各国，革命以不同的形式进行，并产生了大量的财富转移。然后崛起的大国挑战现有大国，引发了战争，之后是货币的崩溃，接着是新秩序的建立。</p>
<p>在1800年代，工业革命发生—贫富差距—战争，我们创造了这个循环。以下这张图展示这样的典型周期的演变。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/6_the_big_cycle.webp" alt="img"></p>
<p>在新的世界秩序下，国家内部外部有新的运作体系，世界如何运作。战争后，世界渴望和平，也往往会出现一个占主导地位、各国不想与之交战的国家，会度过一段和平与繁荣的时期，会带来债务的增加、资本市场的繁荣，然后经济会过热，在这个过程中贫富差距变大，也会出现巨大的泡沫。在资本市场的环境下，繁荣就会产生这样的结果，当经济下行，债务危机发生，泡沫破灭，然后无可避免的催生信贷危机。债务是收到货币的权利，假如货币不够，就会印钞，以及创造更多的信贷，之后会出现内部和外部冲突，通常是革命、战争等形式。这导致了体系的转变，带来体系的重组，也就产生了新的世界秩序。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/7_the_rises_and_declines_of_reserve_currencies.webp" alt="img"></p>
<p>所有这些事件是有规律的，我在上文的周期表中用八个衡量国家实力的维度，来解释通常的周期是什么样的。包括人们的教育程度、创新和科技、在全球范围竞争力、军事力量、贸易量、经济产出、资源分配功能的金融中心的发展情况，以及储备货币的地位。整个周期能体现在这些曲线当中。 </p>
<h3 id="我们预计，全球将损失23万亿美元"><a href="#我们预计，全球将损失23万亿美元" class="headerlink" title="我们预计，全球将损失23万亿美元"></a>我们预计，全球将损失23万亿美元</h3><p>我们可以看到，教育不光是正式的教育，比如理解历史、数学、科学等等，而是说对人整体的教育，让大家成为非常文明的、负责任的公民，这种教育是推动社会进步的根本性因素。在这之后，就是创新和科技。比如，荷兰发明了可以全球航行的舰船，可以说他们发明了资本主义，把资源调动起来。荷兰东印度公司是世界上第一支股票，并且是世界上第一个股票交易所，来整合资本市场，给业务提供资金。荷兰发明了很多很多东西，17世纪25%的发明都是来自荷兰。有了这些，他们就有了全球竞争力，发展军事力量，在全球范围内活动，他们需要供应链，进行国际贸易，把世界上的财富都聚拢到荷兰。这使荷兰的产出进一步增加，产生财富，然后发展金融中心。阿姆斯特丹是当时的世界金融中心。之后他们的负债过多，并逐渐衰落。</p>
<p>这时，英国学习了这些技术，他们在同样的技术领域变得更加强大，比如造船业等等，然后在军事上越来越强大，在1780年英国打败了荷兰，然后英国创造了类似的资本体系，英国东印度公司取代了荷兰东印度贸易公司。然后开始发明，并促成了工业革命，这使得英国崛起，直到一战和二战英国才逐渐衰落。两次世界大战使英国负债累累。周期就是以这样的方式进行的。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/8_the_rases_and_declines.webp" alt="img"></p>
<p>这就是上文提到的曲线，显示每个帝国，荷兰、英国、美国还有中国的类似的故事。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/9_the_power_of_China.webp" alt="img"></p>
<p>这个图显示中国的情况。帝国的兴衰让我非常感兴趣，我开始深入研究中国不同朝代的发展道路，一直追溯到唐朝之前。同样的曲线和规律存在。在一些中国学者的帮助下，我学到了很多，看到了同样的规律。</p>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/10_the_virus.webp" alt="img"></p>
<p>这就是新冠肺炎疫情发生前的一个大背景，当然我们现在必须集中精力来应对疫情，因为这是当前最紧要的问题。但这是一个压力测试，无论出于什么原因，经济下行总会发生。这次的原因是疫情，在观察大的背景时，了解全球宏观投资环境也是我工作的一部分，所以我得非常仔细地观察每个国家的情况，所以我们分析了疫情对世界各国的影响。</p>
<p>我认为，每一个个人、每一个公司、每一个国家都有收入、有支出、有储蓄，当收入相对支出下降时，就会对净收入带来影响。如果它低于支出，那么大家就要动用储蓄了。当然这也取决于有多少储蓄，以及储蓄是什么形式。</p>
<p>我们预测了一下这次的疫情对各个国家、各个公司以及对个人的收入有什么影响，<strong>我们预计，全球将损失23万亿美元</strong>。<strong>我不知道疫情最终会造成什么结果，我认为这次疫情其实很像海啸，退去后，造成的伤害却遗留下来。</strong></p>
<p>我们预计疫情造成GDP下降，以及失业率的上升，可能会和大萧条时期的情况差不多，比2008年严重得多。我们可以看到中央银行的必要性，特别是美国的中央银行，掌握着世界的储备货币。美联储开始通过印钞填补经济损失，中央政府分发美元来创造以美元计价的信贷，然后由美联储来印钞。现在欧洲也在用类似的方法应对，差不多每个国家也都有类似措施。现在大多数的货币和债务仍是以美元计价的，与此同时，美元的实际回报率其实是负的，按其他的计算方法的话也是0。所以，投资者没有理由要持有美元。现在央行在做的事情，和在战争期间是一样的，这就是我们现在所处的局势。</p>
<h3 id="疫后，我们所认识的资本主义会被彻底改变"><a href="#疫后，我们所认识的资本主义会被彻底改变" class="headerlink" title="疫后，我们所认识的资本主义会被彻底改变"></a>疫后，我们所认识的资本主义会被彻底改变</h3><p>上文提到的三个因素会决定经济如何恢复。未来的世界格局将会是完全不同的。</p>
<blockquote>
<p>The Three Big Issues</p>
<blockquote>
<ol>
<li><p>End of long term debt cycle</p>
</li>
<li><p>Wealth and political gaps</p>
</li>
<li><p>The rise of a great power (China) to challenge the existing great Power </p>
</li>
</ol>
</blockquote>
</blockquote>
<p><strong>货币、信贷和债务体系的运作和从前肯定是不一样的，我们所认识的资本主义会被彻底改变。</strong>因为在结构上，无法再利用利率来刺激经济。此外，通过量化宽松政策，央行来购买资产，比如说债券，然后把这些资产通过金融体系有效分配出去。央行将货币和信贷注入到系统中，然后贷款体系来决定如何分配资本。如果贷款能够合理分配，就能获得收益；如果借款人能够合理使用资本的话，也能赚钱。但现在已经这些都行不通了，因为资金和信贷到不了最需要的人手里。</p>
<p>当央行和政府说，我们需要把钱给到特定的人和公司的手上，做法就完全不同了。因为现在贫富差距很大，非常具有挑战性。今年又处在美国总统大选年，所以我们将看到有关财富应该如何分配的争论。富人和穷人间的矛盾以及这个体系应该如何运作将会引发争论。我们之前处于一个资本主义鼎盛的时期，减税等政策都是有利于企业的，现在我们会进入一个反思的过程。问题是，美国民主党和共和党能否就这些矛盾达成共识，还是会出现美国两党之间不可解决的冲突，以及这种内部冲突会如何影响未来的走向。所以这个问题需要考虑。这个时期还有中美的问题。但我们正经历着一个比较艰难的时期，整个全球经济都会受到损害。经济情况不好以及这些矛盾，都会导致更紧张的局势。所以，<strong>我们会看到全球化将转向“自给自足”。换句话说，我们不得不根据更严重的两极分化来重组体制，</strong>当然最开始是政治原因推动的，但现在已经超越了政治因素。</p>
<p><strong>之前全球化进程中，应用比较优势来进行生产和供应，以开放自由贸易为主的方式的时代我认为已经过去了，自给自足或独立的原则和紧张局面将是我们未来环境的特点。</strong></p>
<h3 id="对投资者的建议"><a href="#对投资者的建议" class="headerlink" title="对投资者的建议"></a>对投资者的建议</h3><p>我认为有两点主要的内容。第一，投资人大部分会关注持有的债券、股票和私募股权等等资产的价值，但对于货币的价值和货币的问题没有足够的关注。我们知道，如果持有债券，它的回报率是以利率为基础衡量的。而现在利率已经趋于0，那么可以想象一下，在今天这个时代，由于央行已经造成流动性泛滥，意味着你有100块钱，利率是0—1%，你不想但仍会承担货币风险，意味着你100年后才能拿回你的100美元。这些信贷变成了永久债券，甚至可能不会归还本金。换句话说，现在这些央行都在给一个0利率的政策，因为他们有这个权力决定你不需要实质上偿还，所以很多坏账在他们的资产负债表上挂着。不用偿还本金，这是债务免除的一种形式。所以我们可能需要想一下储备货币的起伏兴衰，思考什么才是保值的？</p>
<p>第二，我们知道经济分为两块：实体经济和金融（虚拟）经济。它们相互之间有关系，但是也有各自的供需特征。比如人们持有债务作为资产，债务是获得货币的权利。有很多资产都是以债务来体现的，而央行能够且将会印刷货币来弥补负债。所以，我们需要在更广义的范围里思考哪些是财富保值的载体。同时，我们现在未知的远比已知的多得多。但是我认为，<strong>成功永远更取决于一个人应对未知的能力而不是已知的信息。</strong>所以，在这样的环境下，分散化投资非常重要，要根据不同的地点、货币、和资产类别进行分散化投资。不要坚持传统的投资，分散化投资才是至关重要的。</p>
<h3 id="除革命、战争外的解决不平等的办法"><a href="#除革命、战争外的解决不平等的办法" class="headerlink" title="除革命、战争外的解决不平等的办法"></a>除革命、战争外的解决不平等的办法</h3><p>是否有除革命、战争外的解决不平等的办法？当然有。这个问题的解决办法，一直都在我们自己手里，打仗或者革命都是十分可怕的。我们如果能够超越自我，意识到为了更大的利益，我们必须解决这些问题；意识到我们需要一个能做大蛋糕的新的国内或者国际体制，一个运转顺利的机制，一个基于相互理解和慷慨精神进行分配的机制；意识到我们有足够的财富、创造力和发明能力去改造世界，让世界变得更好；意识到历史上，国内的斗争，不管是变革、战争，都非常惨痛，我们绝对不能这样做。如果我们能意识到这些，超越自己，找到共同的道路，并达成和平共识。理论上我们可以实现，挑战的实际是人性，实际是各党派能否超越自己的局限，还是像历史上一样，去争夺权力和财富。</p>
<h3 id="人们有时只想着赚钱，近乎痴狂、着迷，而不思考金钱的意义"><a href="#人们有时只想着赚钱，近乎痴狂、着迷，而不思考金钱的意义" class="headerlink" title="人们有时只想着赚钱，近乎痴狂、着迷，而不思考金钱的意义"></a>人们有时只想着赚钱，近乎痴狂、着迷，而不思考金钱的意义</h3><p>我仅代表个人观点，而不是让我的观点成为大家的信条。所以我仅从自己的角度讲一讲。<strong>金钱没有任何内在价值，人们有时只想着赚钱，近乎痴狂、着迷，而不思考金钱的意义。</strong>我个人的出身非常普通，父亲是爵士音乐家，母亲是家庭主妇。我在父母的慈爱中长大，在一所公立学校读的书。这就是我成长所需要的一切，我也相信对任何人来说都是这样，有了这些条件，然后进入一个机会公平的世界。也就是说，能否获得平等的教育，能否拥有教育我良好价值观的父母，使我们能投身社会并获得机会，之后开启各自的人生探险，继续学习，以自己的方式繁荣成长。</p>
<p>我来自于一个普通的中低产家庭，不穷，但是收入中低等。然后我赚到了钱，<strong>我不希望我的小孩有过多的钱。我觉得钱没有那么重要，重要的是机会公平的环境，</strong>这样对社会是好的。我也会觉得很欣慰，对于那些遭遇不公的人，我感同身受。我该拿我的钱做什么？可以享乐，但我相信我有一个责任，而且这也是我的乐见其成的事情，就是做慈善事业，让钱最好地服务整个生态体系。这是我个人对于金钱的想法。</p>
<h3 id="我的儿子“教”我做慈善"><a href="#我的儿子“教”我做慈善" class="headerlink" title="我的儿子“教”我做慈善"></a>我的儿子“教”我做慈善</h3><p> 我来介绍一下我的经历。我1984年来到中国时把孩子也带来了，九十年代的时候，我儿子11岁，我们把他放在了一个北京当地的学校里上学。他有机会接触到中国福利院的孤儿，也了解到大约500美元就能拯救一条生命。他说，在这种情况下怎么能不去尝试拯救生命呢？当时中国还是经济条件落后的国家，他需要这样的支持，当时我钱不多，但是也有一些积蓄。和邻居一起，我们开始募集善款。之后，我儿子成立了一个基金会。所以，其实是他教我做慈善的，因为他和我讲，我有这样一个善款的用途。当时，中国慈善还没有发展起来，他在未来的十五年里发展了“中国关爱基金会”，主要是照顾有特殊需求的孤儿。我也很荣幸能够参与其中，认识了很多很棒的人，比如王振耀等等，也接触了最贫困、最需要帮助的人。在整个基金会募集善款和运营的期间，他募集了大概1500万美元的善款。后来<strong>我们意识到，在逐渐有钱、有资源了以后，我们能够带到中国来的最重要的东西，就是关于慈善的知识。</strong>于是，我找到王振耀和其他的中国慈善家，还找到了比尔·盖茨，一起成立了一个学院来教授慈善，成为慈善领域的专家。</p>
<p>出于一种集体意识，我相信一个好的社会成员应该要与大家分享，所以当时我们也参与了很多其他的项目，遇到了很多优秀的人，比如汪建熙。这就是我的经历，给了我很多快乐。</p>
<h3 id="生命旅程中有三个阶段"><a href="#生命旅程中有三个阶段" class="headerlink" title="生命旅程中有三个阶段"></a>生命旅程中有三个阶段</h3><p>什么是英雄？约瑟夫·坎贝尔写过一本书叫作《千面英雄》，给了这个问题一个很好的答案，历史也佐证了这个答案。人的生命有周期，我们有不同的人生轨迹，天性不同。人之天性不同，我们生而不同。我们行为不同，志向不同。在我们之中，总会有某一类人走入所谓的“英雄的旅程”生命轨迹中，成为拓荒者。他们走向远方，体验生活。</p>
<p><strong>我认为生命旅程中有三个阶段。</strong>最基本的第一阶段中，需要依赖别人，需要学习。之后，步入更大的世界，经历各种事情，包括失败与成功。这些失败会考验人，有的人从此一蹶不振，但也有人跌倒后爬起来，吸取经验教训，再继续向前。</p>
<p>接下来他们会发现一个共同的使命，他们会发现自己一个人的力量不足以完成这个任务，需要与人合作。于是他们开始与同伴一起分担这个共同的使命，并且随着时间流逝，这个使命本身和周围的伙伴变成越来越重要，甚至比他们自己更加重要。他们经历了这种发展过程，<strong>把其他人和他们共同的任务放在自身利益之上的时刻，也就是他们成为英雄的时刻。</strong></p>
<p>在生命旅程稍微晚些的时候，他们会迎来人生的第三阶段，并完成过渡。<strong>第一阶段是你要依赖别人；第二个阶段里别人依赖你，你需要工作；第三阶段里，你需要进行过渡，帮助别人在没你的情况下仍取得成功。</strong>这是很自然的一个过程。</p>
<p>我现在就处在第三个阶段，我觉得非常有意思，因为我观察它，研究人的特性和心理学，以及不同的人是怎样的，他们的倾向是什么。世界上也许只有有限的性格类型，比如25或50种。人们所扮演的角色数量也是有限的，可能是100个或者200个角色。而历史上唯一的变化就是我们改变了着装，改变了所使用的技术。但如果纵观整个历史呢？那基本上就是这些不同性格类型的人不断互动，一次次经历相同类型的事情。</p>
<p>所谓的英雄就是我刚刚描述的这一类人物。这是否意味着每个人都必须成为英雄？大多数人不必成为英雄，大多数人都不是英雄，但这不重要。不论是什么角色，他们都同等重要，他们都扮演着自己的角色，这就是人生的旅程的模样。</p>
]]></content>
      <categories>
        <category>言论</category>
      </categories>
      <tags>
        <tag>economy</tag>
        <tag>era</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5基础</title>
    <url>/2020/08/27/Spring5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Spring-5-基础"><a href="#Spring-5-基础" class="headerlink" title="Spring 5 基础"></a>Spring 5 基础</h1><blockquote>
<p>学习资料：尚硅谷-Spring5框架2020最新版教程</p>
<p><a href="https://www.bilibili.com/video/BV1Vf4y127N5" target="_blank" rel="noopener">视频链接</a></p>
<p><a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a></p>
</blockquote>
<p><img src="https://2020-05-13-my-pic-bed.oss-cn-beijing.aliyuncs.com/2020-05-picgo/spring-overview.png" alt=""></p>
<h2 id="1-Spring-概述"><a href="#1-Spring-概述" class="headerlink" title="1. Spring 概述"></a>1. Spring 概述</h2><ol>
<li>Spring 是轻量级的开源的JavaEE框架</li>
<li>Spring 可以减少企业应用开发的复杂性</li>
<li>Spring 有两个核心部分：IoC和AOP<ol>
<li>IoC：Inversion of Control，控制反转，把创建对象的过程交给Spring进行管理。</li>
<li>AOP：Aspect Oriented Program，面向切面编程，不修改源代码进行功能增强。</li>
</ol>
</li>
<li>Spring 特点<ul>
<li>方便解耦，简化开发</li>
<li>AOP编程支持</li>
<li>方便程序测试</li>
<li>方便和其他框架进行整合</li>
<li>方便进行事务操作</li>
<li>降低API开发难度</li>
</ul>
</li>
</ol>
<h2 id="2-IoC"><a href="#2-IoC" class="headerlink" title="2. IoC"></a>2. IoC</h2><h3 id="2-1-什么是IoC？"><a href="#2-1-什么是IoC？" class="headerlink" title="2.1 什么是IoC？"></a>2.1 什么是IoC？</h3><p><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">Inversion of Control</a>，是软件工程中的一个编程原则。不同于传统控制流，IoC反转了控制流。在IoC中，应用程序从一个通用框架(如Spring)中接收控制流。与传统的过程编程相比，具有这种设计的软件架构会反转控制：在传统的编程中，表达程序目的的自定义代码调用可重用的库来处理通用任务，但是在控制反转的情况下，是框架调用自定义或特定于任务的代码。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/AD-milk/p/13375178.html" target="_blank" rel="noopener">依赖倒置、依赖注入、控制反转都是啥？</a></p>
</blockquote>
<h3 id="2-2-IoC有什么用？"><a href="#2-2-IoC有什么用？" class="headerlink" title="2.2 IoC有什么用？"></a>2.2 IoC有什么用？</h3><p>控制反转又被称为”Hollywood Principle: Don’t call us, we’ll call you”。服务于以下设计目的：</p>
<ul>
<li>解耦功能的执行和实现</li>
<li>提高软件模块化程度</li>
<li>提高软件的可扩展性</li>
</ul>
<h3 id="2-3-IoC原理"><a href="#2-3-IoC原理" class="headerlink" title="2.3 IoC原理"></a>2.3 IoC原理</h3><p>技术支持：xml解析+工厂模式+反射机制。</p>
<p>IoC思想基于IoC容器完成，IoC容器底层是一个对象工厂。</p>
<p>Spring提供两个接口实现IoC容器：</p>
<ul>
<li>BeanFactory: IoC容器的基本实现，是Spring内部使用的接口，不提供给开发人员进行使用；加载配置文件时不会创建对象，在使用它获取对象时才会创建对象。</li>
<li>ApplicationContext: BeanFactory的子接口，提供更多的功能，一般由开发人员进行使用；加载配置文件时就会创建配置文件中定义的对象。</li>
</ul>
<h3 id="2-4-Bean管理"><a href="#2-4-Bean管理" class="headerlink" title="2.4 Bean管理"></a>2.4 Bean管理</h3><p>（1）Bean管理指操作：</p>
<ul>
<li>创建对象</li>
<li>注入对象的属性</li>
</ul>
<p>（2）实现方式：</p>
<ul>
<li>基于xml配置文件</li>
<li>基于注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--xml文件中创建对象，默认执行无参构造方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id属性：唯一标识--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--class属性：类的全路径--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"learn.spring.User"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）基于xml文件注入对象的属性</p>
<ul>
<li><p>依赖注入(Dependency Injection)</p>
<ol>
<li><p>使用setter方法注入属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建对象，默认执行无参构造方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"learn.spring.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property完成属性注入，其通过调用相应的setter方法设置属性</span></span><br><span class="line"><span class="comment">        name属性：属性名称</span></span><br><span class="line"><span class="comment">        value属性：属性的值（字符串形式）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"孙悟空"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置空值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置特殊字符</span></span><br><span class="line"><span class="comment">	1.使用xml中的实体引用&amp;lt(&lt;),&amp;gt(&gt;),&amp;amp(&amp;),&amp;apos('),&amp;quot(")</span></span><br><span class="line"><span class="comment">	2.使用CDATA,CDATA 部分中的所有内容都会被解析器忽略。</span></span><br><span class="line"><span class="comment">	CDATA 部分由 "&lt;![CDATA[" 开始，由 "]]&gt;" 结束：</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>使用有参构造方法注入属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"vipUser"</span> <span class="attr">class</span>=<span class="string">"learn.spring.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过有参构造注入属性，name属性指定属性名称(使用index属性也可以，但不推荐)，value指定值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"23"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"唐三藏"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果需要注入外部bean(属性类型为自定义类)，使用ref属性代替value--&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li><p>注入外部bean</p>
</li>
<li><p>注入内部bean和级联赋值</p>
</li>
<li><p>注入数组、list、map、set……</p>
</li>
</ul>
<p>（4）普通bean和工厂bean</p>
<ul>
<li>普通bean：在xml文件中定义的bean类型与返回类型一致</li>
<li>工厂bean：在xml文件中定义的bean类型与返回类型可能不一致<br>实现：类实现FactoryBean接口</li>
</ul>
<p>（5）bean的作用域</p>
<ul>
<li>Spring中可以设置bean实例是单实例还是多实例</li>
<li>默认情况下是单实例的对象</li>
<li>可以通过设置bean的<code>scope</code>属性的值改变为多实例<ol>
<li>prototype：多实例，在调用getBean方法时才会创建对象</li>
<li>singleton：单实例，默认值，加载配置文件时就会创建对象</li>
</ol>
</li>
</ul>
<p>（6）bean的生命周期</p>
<ul>
<li>生命周期：对象从创建到销毁的过程</li>
<li>bean的生命周期<ol>
<li>通过构造器创建bean实例(无参构造方法)</li>
<li>为bean实例的属性设置值和对其他bean的引用(setter方法)</li>
<li>把bean实例传给后置处理器的postProcessBeforeInitialization方法</li>
<li>调用bean的初始化方法(需要配置bean的<code>init-method</code>属性)</li>
<li>把bean实例传给后置处理器的postProcessAfterInitialization方法</li>
<li>bean的使用</li>
<li>容器关闭时，调用bean的销毁方法(需要配置bean的<code>destroy-method</code>属性)</li>
</ol>
</li>
</ul>
<p>（7）xml自动装配</p>
<ul>
<li>自动装配：指根据指定的装配规则（按照属性名称或属性类型），Spring自动将匹配的属性值进行注入。</li>
<li>实现：借助bean的<code>autowire</code>属性，其有以下两个取值<ol>
<li>byName：根据属性名称注入，注入的bean的id和类属性名称一致</li>
<li>byType：根据类型注入，此时类型应当唯一，否则无法自动装配</li>
</ol>
</li>
</ul>
<p>（8）properties+xml完成注入</p>
<p>（9）基于注解完成注入</p>
<ul>
<li><p>注解：代码的特殊标记</p>
<ol>
<li>格式：@注解名称(属性名称=属性值……)</li>
<li>注解可以作用于类、类方法、类属性等上</li>
<li>使用注解可以简化xml配置</li>
</ol>
</li>
<li><p>Spring中创建bean对象的注解</p>
<ol>
<li>@Component</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Repository</li>
</ol>
<p><em>*上面4个注解的功能相同，均可以用于创建bean实例，但是习惯上在不同的软件层用不同的注解</em></p>
</li>
<li><p>基于注解完成属性注入</p>
<ol>
<li>@autowired:根据属性类型自动装配</li>
<li>@Qualifier:根据属性名称进行注入</li>
<li>@Resource:可以根据类型，也可以根据名称进行注入</li>
<li>@Value:注入普通类型属性</li>
</ol>
</li>
</ul>
<h2 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3. AOP"></a>3. AOP</h2><h3 id="3-1-什么是AOP"><a href="#3-1-什么是AOP" class="headerlink" title="3.1 什么是AOP"></a>3.1 什么是AOP</h3><p><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">aspect-oriented programming</a> (AOP), 面向切面编程，功能模块化，不通过修改源代码而是加更多的模块来拓展功能。</p>
<h3 id="3-2-AOP底层原理"><a href="#3-2-AOP底层原理" class="headerlink" title="3.2 AOP底层原理"></a>3.2 AOP底层原理</h3><p>底层使用动态代理，有以下两种情况：</p>
<ol>
<li><p>有接口时，使用JDK动态代理，创建接口实现类的代理对象，增强类的方法。</p>
<ol>
<li><p>使用java.lang.reflect.Proxy类里的方法创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Object</span><br><span class="line">newProxyInstance(</span><br><span class="line">    ClassLoader loader, </span><br><span class="line">    Class&lt;?&gt;[] interfaces,</span><br><span class="line">    InvocationHandler h)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>编写JDK动态代理代码:</p>
<ol>
<li>创建接口，定义方法</li>
<li>创建接口实现类，实现方法</li>
<li>使用Proxy类创建接口代理对象</li>
</ol>
</li>
</ol>
<ol start="2">
<li>没有接口时，使用CGLIB动态代理，创建子类的代理对象，增强类的方法。</li>
</ol>
<h3 id="3-3-AOP术语"><a href="#3-3-AOP术语" class="headerlink" title="3.3 AOP术语"></a>3.3 AOP术语</h3><ol>
<li><code>连接点</code>：类中哪些方法可以被增强，这些方法就被成为连接点。</li>
<li><code>切入点</code>：实际被增强的方法，称为切入点。</li>
<li><code>通知</code>：实际增强的逻辑部分，也叫<code>增强</code>，主要有五种类型：<ol>
<li>前置通知<code>@Before</code></li>
<li>后置通知<code>@AfterReturning</code></li>
<li>环绕通知<code>@Around</code></li>
<li>异常通知<code>@AfterThrowing</code></li>
<li>最终通知<code>@After</code></li>
</ol>
</li>
<li><code>切面</code>：把<code>通知</code>应用到<code>切入点</code>的过程。</li>
</ol>
<h3 id="3-4-AOP操作"><a href="#3-4-AOP操作" class="headerlink" title="3.4 AOP操作"></a>3.4 AOP操作</h3><p>Spring框架一般都是基于AspectJ实现AOP操作；注意，AspectJ不是Spring的组成部分，而是独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。</p>
<p>基于AspectJ实现AOP操作有两种基本方式：</p>
<ol>
<li>基于xml配置文件实现</li>
<li>基于注解方法实现</li>
</ol>
<p>通过<code>切入点表达式</code>指定进行增强的方法，语法结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符][返回值类型][类全路径][方法名]([参数列表]))</span><br></pre></td></tr></table></figure>

<h3 id="3-5-基于注解实现AOP"><a href="#3-5-基于注解实现AOP" class="headerlink" title="3.5 基于注解实现AOP"></a>3.5 基于注解实现AOP</h3><ol>
<li><p>创建待增强类</p>
</li>
<li><p>创建增强类，编写增强逻辑（5种通知）</p>
</li>
<li><p>进行通知的配置（配置文件或注解）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"learn.spring.aop"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--生成代理--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"learn.spring.aop"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>相同的切入点抽取<code>@Pointcut</code></p>
</li>
</ol>
<h3 id="3-6-基于xml配置文件实现"><a href="#3-6-基于xml配置文件实现" class="headerlink" title="3.6 基于xml配置文件实现"></a>3.6 基于xml配置文件实现</h3><p>实际使用AOP多用注解，灵活方便，基于配置文件了解下即可。</p>
<ol>
<li>创建两个类，增强类和被增强类，创建方法。</li>
<li>在Spring 配置文件中创建两个类对象。</li>
<li>在Spring配置文件中配置切入点。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
